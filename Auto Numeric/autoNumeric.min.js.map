{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///autoNumeric.min.js","webpack:///webpack/bootstrap cef88720a77bb27dabf5","webpack:///./src/autoNumeric.js","webpack:///external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Object","defineProperty","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","TypeError","_typeof","obj","constructor","prototype","autoFormat","autoUnFormat","getDefaultConfig","validate","areSettingsValid","allowedTagList","defaultSettings","aSep","nSep","dGroup","aDec","altDec","aSign","pSign","pNeg","aSuffix","oLimits","vMax","vMin","mDec","eDec","scaleDivisor","scaleDecimal","scaleSymbol","aStor","mRound","aPad","nBracket","wEmpty","lZero","aForm","sNumber","anDefault","unSetOnSubmit","outputType","debug","keyCode","Backspace","Tab","Enter","Shift","Ctrl","Alt","PauseBreak","CapsLock","Esc","Space","PageUp","PageDown","End","Home","LeftArrow","UpArrow","RightArrow","DownArrow","Insert","Delete","num0","num1","num2","num3","num4","num5","num6","num7","num8","num9","a","b","d","e","f","g","h","j","k","l","n","o","q","r","s","t","u","v","w","x","y","z","Windows","RightClick","numpad0","numpad1","numpad2","numpad3","numpad4","numpad5","numpad6","numpad7","numpad8","numpad9","MultiplyNumpad","PlusNumpad","MinusNumpad","DotNumpad","SlashNumpad","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NumLock","ScrollLock","MyComputer","MyCalculator","Semicolon","Equal","Comma","Hyphen","Dot","Slash","Backquote","LeftBracket","Backslash","RightBracket","Quote","Command","apply","$","isNull","isUndefined","isUndefinedOrNullOrEmpty","isString","str","String","isBoolean","isTrueOrFalseString","lowercaseValue","toLowerCase","isObject","reference","isEmptyObj","prop","hasOwnProperty","isValidPasteText","text","isNaN","preparePastedText","holder","autoStrip","settingsClone","replace","contains","needle","indexOf","isInArray","array","toString","Error","hasDecimals","_str$split","split","_str$split2","decimalPart","decimalPlaces","_str$split3","_str$split4","getElementSelection","that","position","selectionStart","focus","select","document","selection","createRange","moveStart","end","start","selectionEnd","setElementSelection","range","createTextRange","collapse","moveEnd","throwError","message","warning","suppressWarnings","arguments","console","warn","runCallbacks","$this","settings","each","val","autoNumeric","decLength","vMaxLength","vMinLength","Math","max","autoCode","mIntPos","mIntNeg","oDec","Number","aNegReg","aNeg","aNegRegAutoStrip","skipFirstAutoStrip","RegExp","skipLastAutoStrip","allowed","allowedAutoStrip","numRegAutoStrip","trailingNegative","match","join","nSign","_s$split","_s$split2","integerPart","modifiedIntegerPart","charAt","slice","onOff","stripReg","negativeBracket","_settings$nBracket$sp","_settings$nBracket$sp2","firstBracket","lastBracket","fromLocale","lastIndexOf","toLocale","locale","result","fixNumber","presentNumber","checkEmpty","inputValue","signOnEmpty","autoGroup","strip","empty","isNeg","digitalGroup","_inputValue$split","_inputValue$split2","_inputValue$split3","_inputValue$split4","test","substring","rawValue","truncateZeros","roundedInputValue","rDec","regex","autoRound","round","ceil","floor","ivRounded","dPos","vdPos","cDec","zeros","rLength","tRound","odd","ivArray","truncateDecimal","paste","_s$split3","_s$split4","modifiedDecimalPart","parseStr","nL","search","testMinMax","xc","yc","xNeg","autoCheck","minParse","maxParse","valParse","autoGet","getHolder","$that","update","data","AutoNumericHolder","get","keepOriginalSettings","oPad","oBracket","oSep","oSign","oSuffix","readCookie","name","nameEQ","ca","cookie","storageTest","mod","sessionStorage","setItem","removeItem","autoSave","toDo","storedName","decodeURIComponent","date","expires","Date","setTime","getTime","toUTCString","getItem","formatted","_getStringOrArray","getArrayBehavior","formIndex","index","allFormElements","aiIndex","scIndex","rSubmitterTypes","rSubmittable","rCheckableType","rNonAutoNumericTypes","count","field","localName","type","disabled","checked","formFields","serializeArray","scElement","inArray","testInput","_ret2","serialize","formParts","_formParts$i$split","_formParts$i$split2","inputName","modifiedInputValue","onFocusInAndMouseEnter","on","$settings","is","inVal","lastVal","onEmpty","onKeydown","readOnly","processed","init","skipAlways","processAlways","formatQuick","currentValue","throwInput","trigger","preventDefault","onKeypress","shiftKey","processKeypress","onKeyup","skip","tab","kdCode","valuePartsBeforePaste","onFocusOutAndMouseLeave","origValue","_autoCheck3","_autoCheck4","minTest","maxTest","groupedValue","change","onPaste","oldRawValue","prefix","suffix","pastedText","originalEvent","clipboardData","getData","newValue","valueOf","onSubmit","closest","getInputIfSupportedTagAndType","$input","currentElementTag","formatDefaultValueOnPageLoad","setValue","attr","testedCurrentValue","parseFloat","Infinity","isNumeric","toStrip","tagList","correctPNegOption","options","getInitialSettings","tagData","extend","runOnce","caretFix","key","createCustomEvent","eventName","detail","CustomEvent","bubbles","cancelable","sendCustomEvent","dispatchEvent","ctrlKey","cmdKey","metaKey","which","setSelection","setReal","min","setPosition","pos","getBeforeAfter","left","right","getBeforeAfterStriped","_getBeforeAfter","_getBeforeAfter2","normalizeParts","setValueParts","advent","parts","_autoCheck","_autoCheck2","testValue","signPosition","aSignLen","hasNeg","valueLen","expandSelectionOnSign","checkPaste","oldParts","_getBeforeAfter3","_getBeforeAfter4","modifiedLeftPart","substr","negLen","aSuffixLen","startJump","processTrailing","_ref","_ref2","_getBeforeAfterStripe3","_getBeforeAfterStripe4","_getBeforeAfterStripe","_getBeforeAfterStripe2","_processTrailing","_processTrailing2","cCode","fromCharCode","_getBeforeAfterStripe5","_getBeforeAfterStripe6","_this","leftLength","kuCode","_getBeforeAfterStripe7","_getBeforeAfterStripe8","_leftLength$split","_leftLength$split2","subParts","leftAr","shift","signParts","escapeChr","escapedParts","miniParts","leftReg","newLeft","methods","destroy","removeData","off","wipe","set","_autoCheck5","_autoCheck6","attemptedValue","unSet","reSet","eq","getLocalized","getFormatted","getString","getArray","getSettings","fn","method","_len","args","_key","defaults","_autoCheck7","_autoCheck8","autoUnformat","userOptions","shouldExtendDefaultOptions","testPositiveInteger","testNumericalCharacters","testFloatOrIntegerAndPossibleNegativeSign","testPositiveFloatOrInteger","dpVMin","dpVMax","vMinMaxDecimalPlaces","isValid","error","event","params","evt","createEvent","initCustomEvent","window","Event","default","format","unFormat"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,WACA,kBAAAC,gBAAAC,IACAD,QAAA,UAAAJ,GACA,gBAAAC,SACAA,QAAA,YAAAD,EAAAG,QAAA,WAEAJ,EAAA,YAAAC,EAAAD,EAAA,SACCO,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,QAAA,EAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASP,EAAQD,EAASQ,GAE/B,GAAIS,GAAgCC,EAA8BC,CACrDX,GAAoB,GACzBA,EAAoB,IAC3B,WAED,YAEAY,QAAOC,eAAerB,EAAS,cAC3BsB,OAAO,GAGX,IAAIC,GAAiB,WAAc,QAASC,GAAcC,EAAKC,GAAK,GAAIC,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKR,EAAIS,OAAOC,cAAmBP,GAAMI,EAAKC,EAAGG,QAAQC,QAAoBV,EAAKW,KAAKN,EAAGV,QAAYI,GAAKC,EAAKY,SAAWb,GAA3DE,GAAK,IAAoE,MAAOY,GAAOX,GAAK,EAAMC,EAAKU,EAAO,QAAU,KAAWZ,GAAMK,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUF,EAAKC,GAAK,GAAIe,MAAMC,QAAQjB,GAAQ,MAAOA,EAAY,IAAIS,OAAOC,WAAYf,QAAOK,GAAQ,MAAOD,GAAcC,EAAKC,EAAa,MAAM,IAAIiB,WAAU,4DAEllBC,EAA4B,kBAAXV,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUU,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXX,SAAyBW,EAAIC,cAAgBZ,QAAUW,IAAQX,OAAOa,UAAY,eAAkBF,IEhCnQG,SACAC,SACAC,SACAC,SACAC,SAMEC,GACF,IACA,UACA,OACA,OACA,QACA,KACA,MACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,QACA,KACA,SACA,SACA,IACA,IACA,IACA,SACA,OACA,SACA,KACA,KACA,KASEC,GASFC,KAAM,IAMNC,MAAM,EAQNC,OAAQ,IAMRC,KAAM,IAMNC,OAAQ,KAORC,MAAO,GAMPC,MAAO,IAYPC,KAAM,IAMNC,QAAS,GAOTC,QAAS,KAMTC,KAAM,mBAMNC,KAAM,oBAKNC,KAAM,KAMNC,KAAM,KAcNC,aAAc,KAMdC,aAAc,KAMdC,YAAa,KAKbC,OAAO,EAgBPC,OAAQ,IASRC,MAAM,EAQNC,SAAU,KASVC,OAAQ,QAORC,MAAO,OAMPC,OAAO,EAMPC,SAAS,EAQTC,UAAW,KAMXC,eAAe,EASfC,WAAY,KAMZC,OAAO,GAMLC,GACFC,UAAgB,EAChBC,IAAgB,EAChBC,MAAgB,GAChBC,MAAgB,GAChBC,KAAgB,GAChBC,IAAgB,GAChBC,WAAgB,GAChBC,SAAgB,GAChBC,IAAgB,GAChBC,MAAgB,GAChBC,OAAgB,GAChBC,SAAgB,GAChBC,IAAgB,GAChBC,KAAgB,GAChBC,UAAgB,GAChBC,QAAgB,GAChBC,WAAgB,GAChBC,UAAgB,GAChBC,OAAgB,GAChBC,OAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,KAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBrG,EAAgB,GAChBsG,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChB/F,EAAgB,GAChBgG,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChB9G,EAAgB,GAChB+G,EAAgB,GAChBC,EAAgB,GAChB9G,EAAgB,GAChB+G,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,EAAgB,GAChBC,QAAgB,GAChBC,WAAgB,GAChBC,QAAgB,GAChBC,QAAgB,GAChBC,QAAgB,GAChBC,QAAgB,GAChBC,QAAgB,IAChBC,QAAgB,IAChBC,QAAgB,IAChBC,QAAgB,IAChBC,QAAgB,IAChBC,QAAgB,IAChBC,eAAgB,IAChBC,WAAgB,IAChBC,YAAgB,IAChBC,UAAgB,IAChBC,YAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,GAAgB,IAChBC,IAAgB,IAChBC,IAAgB,IAChBC,IAAgB,IAChBC,QAAgB,IAChBC,WAAgB,IAChBC,WAAgB,IAChBC,aAAgB,IAChBC,UAAgB,IAChBC,MAAgB,IAChBC,MAAgB,IAChBC,OAAgB,IAChBC,IAAgB,IAChBC,MAAgB,IAChBC,UAAgB,IAChBC,YAAgB,IAChBC,UAAgB,IAChBC,aAAgB,IAChBC,MAAgB,IAChBC,QAAgB,MAInB,SAAStL,GAINmB,GAAQV,EAAA,IAARS,EAAA,EAAAE,EAAA,kBAAAF,KAAAqK,MAAAtL,EAAAkB,GAAAD,IAAAc,SAAAZ,IAAAlB,EAAAD,QAAAmB,KAQF,SAAAoK,GAUE,QAASC,GAAOlK,GACZ,MAAiB,QAAVA,EAUX,QAASmK,GAAYnK,GACjB,MAAiB,UAAVA,EASX,QAASoK,GAAyBpK,GAC9B,MAAiB,QAAVA,GAA4B,SAAVA,GAAqB,KAAOA,EASzD,QAASqK,GAASC,GACd,MAAuB,gBAARA,IAAoBA,YAAeC,QAUtD,QAASC,GAAUxK,GACf,MAAyB,iBAAXA,GAUlB,QAASyK,GAAoBzK,GACzB,GAAM0K,GAAiBH,OAAOvK,GAAO2K,aACrC,OAA0B,SAAnBD,GAAgD,UAAnBA,EASxC,QAASE,GAASC,GACd,MAA4B,YAArB,mBAAOA,GAAP,YAAAvJ,EAAOuJ,KAAwC,OAAdA,IAAuB1J,MAAMC,QAAQyJ,GAUjF,QAASC,GAAWvJ,GAChB,IAAK,GAAMwJ,KAAQxJ,GACf,GAAIA,EAAIyJ,eAAeD,GACnB,OAAO,CAGf,QAAO,EASX,QAASE,GAAiBC,GACtB,MAAgB,KAATA,IAAgBC,MAAMD,GAUjC,QAASE,GAAkBF,EAAMG,GAC7B,MAAOC,GAAUJ,EAAMG,EAAOE,eAAeC,QAAQH,EAAOE,cAAcnJ,KAAM,KAWpF,QAASqJ,GAASnB,EAAKoB,GACnB,SAAKrB,EAASC,KAASD,EAASqB,IAAmB,KAARpB,GAAyB,KAAXoB,IAIlDpB,EAAIqB,QAAQD,MAAY,EAUnC,QAASE,GAAUF,EAAQG,GACvB,SAAKzK,EAAQyK,IAAUA,QAAgB1B,EAAYuB,KAI5CG,EAAMF,QAAQD,MAAY,EAUrC,QAAStK,GAAQjB,GACb,GAA2C,mBAAvCL,OAAO2B,UAAUqK,SAASvM,SAE1B,MAAO4B,OAAMC,QAAQjB,IAAwB,YAAf,mBAAOA,GAAP,YAAAmB,EAAOnB,KAA4D,mBAAxCL,OAAO2B,UAAUqK,SAASvM,KAAKY,EAGxF,MAAM,IAAI4L,OAAM,6CAUxB,QAASC,GAAY1B,GAAK,GAAA2B,GACE3B,EAAI4B,MAAM,KADZC,EAAAlM,EAAAgM,EAAA,GACbG,EADaD,EAAA,EAEtB,QAAQhC,EAAYiC,GAUxB,QAASC,GAAc/B,GAAK,GAAAgC,GACAhC,EAAI4B,MAAM,KADVK,EAAAtM,EAAAqM,EAAA,GACfF,EADeG,EAAA,EAExB,OAAKpC,GAAYiC,GAIV,KAHIA,EAAYnL,OAS3B,QAASuL,GAAoBC,GACzB,GAAMC,KACN,IAAIvC,EAAYsC,EAAKE,gBAAiB,CAClCF,EAAKG,OACL,IAAMC,GAASC,SAASC,UAAUC,aAClCN,GAASzL,OAAS4L,EAAO3B,KAAKjK,OAC9B4L,EAAOI,UAAU,aAAcR,EAAKzM,MAAMiB,QAC1CyL,EAASQ,IAAML,EAAO3B,KAAKjK,OAC3ByL,EAASS,MAAQT,EAASQ,IAAMR,EAASzL,WAEzCyL,GAASS,MAAQV,EAAKE,eACtBD,EAASQ,IAAMT,EAAKW,aACpBV,EAASzL,OAASyL,EAASQ,IAAMR,EAASS,KAG9C,OAAOT,GAMX,QAASW,GAAoBZ,EAAMU,EAAOD,GACtC,GAAI/C,EAAYsC,EAAKE,gBAAiB,CAClCF,EAAKG,OACL,IAAMU,GAAQb,EAAKc,iBACnBD,GAAME,UAAS,GACfF,EAAMG,QAAQ,YAAaP,GAC3BI,EAAML,UAAU,YAAaE,GAC7BG,EAAMT,aAENJ,GAAKE,eAAiBQ,EACtBV,EAAKW,aAAeF,EAS5B,QAASQ,GAAWC,GAChB,KAAM,IAAI5B,OAAM4B,GASpB,QAASC,GAAQD,GAAmC,GAA1BE,GAA0BC,UAAA7M,OAAA,GAAAR,SAAAqN,UAAA,IAAAA,UAAA,EAC5CD,IAEAE,QAAQC,KAAR,YAAyBL,GAYjC,QAASM,GAAaC,EAAOC,GAEzBlE,EAAEmE,KAAKD,EAAU,SAAC9H,EAAGgI,GACE,kBAARA,GACPF,EAAS9H,GAAKgI,EAAIH,EAAOC,EAAU9H,GACM,kBAA3B6H,GAAMI,YAAYD,KAEhCF,EAAS9H,GAAK6H,EAAMI,YAAYD,GAAKH,EAAOC,EAAU9H,MAQlE,QAASkI,GAAU3L,EAAMD,GACrB,GAAI6L,GAAa,EACbC,EAAa,CAQjB,OAPI9L,GAAK,KACL6L,EAAa7L,EAAK,GAAG1B,QAErB2B,EAAK,KACL6L,EAAa7L,EAAK,GAAG3B,QAGlByN,KAAKC,IAAIH,EAAYC,GAOhC,QAASG,GAASV,EAAOC,GAErBF,EAAaC,EAAOC,EACpB,IAAMxL,GAAOwL,EAASxL,KAAKmJ,WAAWI,MAAM,KACtCtJ,EAASuL,EAASvL,MAA0B,IAAlBuL,EAASvL,KAAmBuL,EAASvL,KAAKkJ,WAAWI,MAAM,OAC3FvJ,GAAK,GAAKA,EAAK,GAAG6I,QAAQ,IAAK,IAC/B5I,EAAK,GAAKA,EAAK,GAAG4I,QAAQ,IAAK,IAC/B2C,EAASU,QAAUH,KAAKC,IAAIhM,EAAK,GAAG1B,OAAQ,GAC5CkN,EAASW,QAAUJ,KAAKC,IAAI/L,EAAK,GAAG3B,OAAQ,GACtB,OAAlBkN,EAAStL,MACTsL,EAAStL,KAAO0L,EAAU3L,EAAMD,GAChCwL,EAASY,KAAOZ,EAAStL,MAEzBsL,EAAStL,KAAOmM,OAAOb,EAAStL,MAGpCsL,EAAStL,KAAQsL,EAASpL,cAAgBoL,EAASnL,aAAgBmL,EAASnL,aAAemL,EAAStL,KAG5E,OAApBsL,EAAS9L,QAAmB8L,EAAStL,KAAO,IACtB,MAAlBsL,EAAS/L,MAAkC,MAAlB+L,EAASlM,KAClCkM,EAAS9L,OAAS,IACO,MAAlB8L,EAAS/L,MAAkC,MAAlB+L,EAASlM,OACzCkM,EAAS9L,OAAS,KAK1B,IAAM4M,GAAUd,EAASe,KAAT,QAAuBf,EAASe,KAAhC,MAA2C,MAC3Df,GAASgB,iBAAmBF,EAC5Bd,EAASiB,mBAAqB,GAAIC,QAAUJ,EAAd,OAA4Bd,EAASe,KAAT,KAAmBf,EAASe,KAAO,IAA/D,KAAuEf,EAAS/L,KAAhF,iBAAqG+L,EAAS/L,KAA9G,QAC9B+L,EAASmB,kBAAoB,GAAID,QAAJ,SAAoBlB,EAAS/L,KAA7B,SAA0C+L,EAAS/L,KAAnD,YAC7B,IAAMmN,mBAA0BpB,EAAS/L,IAIzC,OAHA+L,GAASqB,iBAAmB,GAAIH,QAAJ,KAAgBE,EAAhB,IAA4B,MACxDpB,EAASsB,gBAAkB,GAAIJ,QAAUJ,EAAd,QAA6Bd,EAAS/L,KAAtC,WAAqD+L,EAAS/L,KAA9D,mBAAqF+L,EAAS/L,KAA9F,YAEpB+L,EAMX,QAAS7C,GAAU3E,EAAGwH,GAKlB,GAJuB,KAAnBA,EAAS7L,QAETqE,EAAIA,EAAE6E,QAAQ2C,EAAS7L,MAAO,KAE9B6L,EAAS1L,QAET,KAAOgJ,EAAS9E,EAAGwH,EAAS1L,UACxBkE,EAAIA,EAAE6E,QAAQ2C,EAAS1L,QAAS,GAKxCkE,GAAIA,EAAE6E,QAAQ2C,EAASiB,mBAAoB,SAEpB,MAAlBjB,EAAS3L,MAAoC,MAAnB2L,EAAS5L,OAAmC,MAAlB4L,EAAS3L,OAAkBiJ,EAAS9E,EAAG,MAAc,KAANA,IACpGwH,EAASuB,kBAAmB,GAIhC/I,EAAIA,EAAE6E,QAAQ2C,EAASmB,kBAAmB,MAG1C3I,EAAIA,EAAE6E,QAAQ2C,EAASqB,iBAAkB,IACrCrB,EAAS9L,SACTsE,EAAIA,EAAE6E,QAAQ2C,EAAS9L,OAAQ8L,EAAS/L,MAI5C,IAAM5C,GAAImH,EAAEgJ,MAAMxB,EAASsB,gBAE3B,IADA9I,EAAInH,GAAKA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAAIoQ,KAAK,IAAM,GACf,UAAnBzB,EAAS5K,OAAwC,SAAnB4K,EAAS5K,MAAkB,CACzD,GAAIsM,GAAQ,GAD6CC,EAEtBnJ,EAAEuF,MAAMiC,EAAS/L,MAFK2N,EAAA9P,EAAA6P,EAAA,GAElDE,EAFkDD,EAAA,GAErC3D,EAFqC2D,EAAA,GAGrDE,EAAsBD,CACtBvE,GAASwE,EAAqB9B,EAASe,QACvCW,EAAQ1B,EAASe,KACjBe,EAAsBA,EAAoBzE,QAAQ2C,EAASe,KAAM,KAIvD,KAAVW,GAAgBI,EAAoBhP,OAASkN,EAASU,SAA6C,MAAlCoB,EAAoBC,OAAO,KAC5FD,EAAsBA,EAAoBE,MAAM,IAItC,KAAVN,GAAgBI,EAAoBhP,OAASkN,EAASW,SAA6C,MAAlCmB,EAAoBC,OAAO,KAC5FD,EAAsBA,EAAoBE,MAAM,IAEpDxJ,KAAOkJ,EAAQI,GAAsB9F,EAAYiC,GAAa,GAAG+B,EAAS/L,KAAOgK,GAErF,GAAK+B,EAASiC,OAA4B,SAAnBjC,EAAS5K,OAAyC,UAAnB4K,EAAS5K,OAAqB4K,EAASiC,SAAU,EAAQ,CAE3G,GAAIC,OAAelC,EAASgB,iBAAxB,SACJkB,GAAW,GAAIhB,QAAOgB,GACtB1J,EAAIA,EAAE6E,QAAQ6E,EAAU,QAG5B,MAAO1J,GAUX,QAAS2J,GAAgB3J,EAAGwH,GACxB,GAAwB,MAAnBA,EAAS5L,OAAmC,MAAlB4L,EAAS3L,MAAqC,MAAnB2L,EAAS5L,OAAmC,MAAlB4L,EAAS3L,KAAe,IAAA+N,GACpEpC,EAAS9K,SAAS6I,MAAM,KAD4CsE,EAAAvQ,EAAAsQ,EAAA,GACjGE,EADiGD,EAAA,GACnFE,EADmFF,EAAA,EAEnGrC,GAASiC,MAGHjC,EAASiC,OAASzJ,EAAEuJ,OAAO,KAAOO,IACzC9J,EAAIA,EAAE6E,QAAQiF,EAActC,EAASe,MACrCvI,EAAIA,EAAE6E,QAAQkF,EAAa,MAJ3B/J,EAAIA,EAAE6E,QAAQ2C,EAASe,KAAM,IAC7BvI,EAAI8J,EAAe9J,EAAI+J,GAO/B,MAAO/J,GAaX,QAASgK,GAAWhK,GAOhB,MANAA,GAAIA,EAAE6E,QAAQ,IAAK,KACfC,EAAS9E,EAAG,MAAQA,EAAEiK,YAAY,OAASjK,EAAE1F,OAAS,IACtD0F,EAAIA,EAAE6E,QAAQ,IAAK,IACnB7E,EAAI,IAAMA,GAGPA,EAOX,QAASkK,GAAS7Q,EAAO8Q,GACrB,GAAI5G,EAAO4G,IAAsB,WAAXA,EAClB,MAAO9Q,EAGX,IAAI+Q,SACJ,QAAQD,GACJ,IAAK,SACDC,EAAS/B,OAAOhP,EAChB,MACJ,KAAK,KACD+Q,EAAStF,EAASzL,EAAO,KAAOA,EAAMwL,QAAQ,IAAK,IAAM,IAAMxL,CAC/D,MACJ,KAAK,IACL,IAAK,KACD+Q,EAAS/Q,EAAMwL,QAAQ,IAAK,IAC5B,MACJ,KAAK,KACDuF,EAAS/Q,EAAMwL,QAAQ,IAAK,KAC5BuF,EAAStF,EAASsF,EAAQ,KAAOA,EAAOvF,QAAQ,IAAK,IAAM,IAAMuF,CACjE,MAEJ,KAAK,IACL,IAAK,KACDA,EAAS/Q,CACT,MACJ,SACI0N,2BAAoCoD,EAApC,+BAGR,MAAOC,GAUX,QAASC,GAAUrK,EAAGwH,GAYlB,MAXsB,MAAlBA,EAAS/L,OACTuE,EAAIA,EAAE6E,QAAQ2C,EAAS/L,KAAM,MAEX,MAAlB+L,EAASe,MAAkC,KAAlBf,EAASe,OAClCvI,EAAIA,EAAE6E,QAAQ2C,EAASe,KAAM,MAE5BvI,EAAEgJ,MAAM,QAEThJ,GAAK,QAGFA,EAUX,QAASsK,GAActK,EAAGwH,GAQtB,MAPsB,MAAlBA,EAASe,MAAkC,KAAlBf,EAASe,OAClCvI,EAAIA,EAAE6E,QAAQ,IAAK2C,EAASe,OAEV,MAAlBf,EAAS/L,OACTuE,EAAIA,EAAE6E,QAAQ,IAAK2C,EAAS/L,OAGzBuE,EAWX,QAASuK,GAAWC,EAAYhD,EAAUiD,GACtC,MAAmB,KAAfD,GAAqBA,IAAehD,EAASe,KACrB,WAApBf,EAAS7K,QAAuB8N,EACN,MAAlBjD,EAAS3L,KAAgB2O,EAAahD,EAAS7L,MAAQ6L,EAAS1L,QAAU0L,EAAS7L,MAAQ6O,EAAahD,EAAS1L,QAGtH0O,EAGJ,KAUX,QAASE,GAAUF,EAAYhD,GACvBA,EAASmD,QACTH,EAAa7F,EAAU6F,EAAYhD,IAGnCA,EAASuB,mBAAqBjE,EAAS0F,EAAY,OACnDA,EAAa,IAAMA,EAGvB,IAAMI,GAAQL,EAAWC,EAAYhD,GAAU,GACzCqD,EAAQ/F,EAAS0F,EAAY,IAKnC,IAJIK,IACAL,EAAaA,EAAW3F,QAAQ,IAAK,KAG3B,OAAV+F,EACA,MAAOA,EAGX,IAAIE,GAAe,EACnBtD,GAAShM,OAASgM,EAAShM,OAAO2J,WAE9B2F,EADoB,MAApBtD,EAAShM,OACM,uBACY,OAApBgM,EAAShM,OACD,oDACY,MAApBgM,EAAShM,OACD,mBAEA,kBA5BkB,IAAAuP,GAgCJP,EAAWjF,MAAMiC,EAAS/L,MAhCtBuP,EAAA1R,EAAAyR,EAAA,GAgChC1B,EAhCgC2B,EAAA,GAgCnBvF,EAhCmBuF,EAAA,EAiCrC,IAAIxD,EAAS9L,QAAU8H,EAAYiC,GAAc,IAAAwF,GAChBT,EAAWjF,MAAMiC,EAAS9L,QADVwP,EAAA5R,EAAA2R,EAAA,EAC5C5B,GAD4C6B,EAAA,GAC/BzF,EAD+ByF,EAAA,GAIjD,GAAsB,KAAlB1D,EAASlM,KAET,KAAOwP,EAAaK,KAAK9B,IACrBA,EAAcA,EAAYxE,QAAQiG,EAApB,KAAuCtD,EAASlM,KAAhD,KAoDtB,OAhDsB,KAAlBkM,EAAStL,MAAesH,EAAYiC,GASpC+E,EAAanB,GART5D,EAAYnL,OAASkN,EAAStL,OAC9BuJ,EAAcA,EAAY2F,UAAU,EAAG5D,EAAStL,OAIpDsO,EAAanB,EAAc7B,EAAS/L,KAAOgK,GAMxB,MAAnB+B,EAAS5L,QACLiP,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAahD,EAASe,KAAOf,EAAS7L,MAAQ6O,GAE9CK,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAahD,EAAS7L,MAAQ6L,EAASe,KAAOiC,GAE9CK,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAahD,EAAS7L,MAAQ6O,EAAahD,EAASe,MAEnDsC,IACDL,EAAahD,EAAS7L,MAAQ6O,IAIf,MAAnBhD,EAAS5L,QACLiP,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAaA,EAAahD,EAAS7L,MAAQ6L,EAASe,MAEpDsC,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAaA,EAAahD,EAASe,KAAOf,EAAS7L,OAEnDkP,GAA2B,MAAlBrD,EAAS3L,OAClB2O,EAAahD,EAASe,KAAOiC,EAAahD,EAAS7L,OAElDkP,IACDL,GAA0BhD,EAAS7L,QAKjB,OAAtB6L,EAAS9K,WAAsB8K,EAAS6D,SAAW,GAA8B,MAAzBb,EAAWjB,OAAO,MAC1EiB,EAAab,EAAgBa,EAAYhD,IAE7CA,EAASuB,kBAAmB,EAErByB,EAAahD,EAAS1L,QAUjC,QAASwP,GAAcC,EAAmBC,GACtC,GAAIC,SACJ,QAAQD,GACJ,IAAK,GAEDC,EAAQ,sBACR,MACJ,KAAK,GAEDA,EAAQ,wBACR,MACJ,SAEIA,EAAQ,GAAI/C,QAAJ,WAAsB8C,EAAtB,sBAShB,MALAD,GAAoBA,EAAkB1G,QAAQ4G,EAAO,MACxC,IAATD,IACAD,EAAoBA,EAAkB1G,QAAQ,MAAO,KAGlD0G,EAaX,QAASG,GAAUlB,EAAYhD,GAE3B,GADAgD,EAA6B,KAAfA,EAAqB,IAAMA,EAAWrF,WAC5B,QAApBqC,EAAShL,QAAwC,QAApBgL,EAAShL,QAAwC,QAApBgL,EAAShL,QAAwC,QAApBgL,EAAShL,OAAkB,CAClH,OAAQgL,EAAShL,QACb,IAAK,MACDgO,GAAczC,KAAK4D,MAAmB,GAAbnB,GAAmB,IAAIrF,UAChD,MACJ,KAAK,MACDqF,GAAczC,KAAK6D,KAAkB,GAAbpB,GAAmB,IAAIrF,UAC/C,MACJ,SACIqF,GAAczC,KAAK8D,MAAmB,GAAbrB,GAAmB,IAAIrF,WAGxD,GAAIiF,SAQJ,OAJIA,GAHCtF,EAAS0F,EAAY,KAEfA,EAAWlQ,OAASkQ,EAAWxF,QAAQ,KAAO,EAC5CwF,EAAa,IAEbA,EAJAA,EAAa,MAS9B,GAAIsB,GAAY,GACZrS,EAAI,EACJyP,EAAQ,GACRsC,QAIAA,GADAhE,EAAS/K,KACF+K,EAAStL,KAET,EAIkB,MAAzBsO,EAAWjB,OAAO,KAClBL,EAAQ,IAGRsB,EAAaA,EAAW3F,QAAQ,IAAK,KAIpC2F,EAAWxB,MAAM,SAClBwB,EAAa,IAAMA,GAIT,MAAVtB,GAAwC,IAAvBb,OAAOmC,KACxBtB,EAAQ,KAIPb,OAAOmC,GAAc,GAAwB,SAAnBhD,EAAS5K,OAAsB4N,EAAWlQ,OAAS,GAAwB,UAAnBkN,EAAS5K,SAC5F4N,EAAaA,EAAW3F,QAAQ,UAAW,MAG/C,IAAMkH,GAAOvB,EAAWP,YAAY,KAG9B+B,EAASD,KAAS,EAAMvB,EAAWlQ,OAAS,EAAIyR,EAIlDE,EAAQzB,EAAWlQ,OAAS,EAAK0R,CAErC,IAAIC,GAAQzE,EAAStL,KAAM,CAGvB,GADA4P,EAAYtB,EACRyB,EAAOT,EAAM,CACTO,KAAS,IACTD,GAAatE,EAAS/L,KAI1B,KADA,GAAIyQ,GAAQ,SACLD,EAAOT,GACVU,EAAQA,EAAMd,UAAU,EAAGI,EAAOS,GAClCH,GAAaI,EACbD,GAAQC,EAAM5R,WAEX2R,GAAOT,EACdM,EAAYR,EAAcQ,EAAWN,GACrB,IAATS,GAAuB,IAATT,IACrBM,EAAYA,EAAUjH,QAAQ,MAAO,IAGzC,OAA8B,KAAtBwD,OAAOyD,GAAoBA,EAAY5C,EAAQ4C,EAI3D,GAAMK,GAAUJ,EAAOvE,EAAStL,KAC1BkQ,EAAS/D,OAAOmC,EAAWjB,OAAO4C,EAAU,IAC5CE,EAAsC,MAA/B7B,EAAWjB,OAAO4C,GAAqB3B,EAAWjB,OAAO4C,EAAU,GAAK,EAAM3B,EAAWjB,OAAO4C,GAAW,EACpHG,EAAU9B,EAAWY,UAAU,EAAGe,EAAU,GAAG5G,MAAM,GAEzD,IAAK6G,EAAS,GAAyB,MAApB5E,EAAShL,QACvB4P,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,KAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,MAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,QACvB4P,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,KAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,MAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,QACZ,IAAX4P,GAAoC,MAApB5E,EAAShL,QAA0B,IAAR6P,GAC3CD,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,KAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,QAA4B,MAAV0M,GACzCkD,EAAS,GAAyB,MAApB5E,EAAShL,OAExB,IAAK/C,EAAK6S,EAAQhS,OAAS,EAAIb,GAAK,EAAGA,GAAK,EACxC,GAAmB,MAAf6S,EAAQ7S,GAAY,CAEpB,GADA6S,EAAQ7S,IAAM6S,EAAQ7S,GAAK,EACvB6S,EAAQ7S,GAAK,GACb,KAGAA,GAAI,IACJ6S,EAAQ7S,GAAK,KAY7B,MALA6S,GAAUA,EAAQ9C,MAAM,EAAG2C,EAAU,GAGrCL,EAAYR,EAAcgB,EAAQrD,KAAK,IAAKuC,GAEd,IAAtBnD,OAAOyD,GAAoBA,EAAY5C,EAAQ4C,EAW3D,QAASS,GAAgBvM,EAAGwH,EAAUgF,GAClC,GAAM/Q,GAAO+L,EAAS/L,KAChBS,EAAOsL,EAAStL,IAGtB,IAFA8D,EAAe,UAAVwM,EAAqBd,EAAU1L,EAAGwH,GAAYxH,EAE/CvE,GAAQS,EAAM,IAAAuQ,GACqBzM,EAAEuF,MAAM9J,GAD7BiR,EAAApT,EAAAmT,EAAA,GACPpD,EADOqD,EAAA,GACMjH,EADNiH,EAAA,EAId,IAAIjH,GAAeA,EAAYnL,OAAS4B,EACpC,GAAIA,EAAO,EAAG,CACV,GAAMyQ,GAAsBlH,EAAY2F,UAAU,EAAGlP,EACrD8D,MAAOqJ,EAAc5N,EAAOkR,MAE5B3M,GAAIqJ,EAKhB,MAAOrJ,GASX,QAAS4M,GAAShN,GACd,GAAMS,MACFhB,SACA5F,SACAoT,SACApN,QA+BJ,IA5BU,IAANG,GAAW,EAAIA,EAAI,IACnBA,EAAI,MAIRA,EAAIA,EAAEuF,WACc,MAAhBvF,EAAE2J,OAAO,IACT3J,EAAIA,EAAE4J,MAAM,GACZnJ,EAAEL,GAAI,GAENK,EAAEL,EAAI,EAIVX,EAAIO,EAAEoF,QAAQ,KACV3F,GAAI,IACJO,EAAIA,EAAEiF,QAAQ,IAAK,KAInBxF,EAAI,IAEJA,EAAIO,EAAEtF,QAIVb,EAAKmG,EAAEkN,OAAO,aAAc,EAAMlN,EAAEtF,OAASsF,EAAEkN,OAAO,UACtDD,EAAKjN,EAAEtF,OACHb,IAAMoT,EAENxM,EAAEhB,EAAI,EACNgB,EAAEvH,GAAK,OACJ,CAEH,IAAK2G,EAAIoN,EAAK,EAAmB,MAAhBjN,EAAE2J,OAAO9J,GAAYA,GAAK,EACvCoN,GAAM,CASV,KAPAA,GAAM,EAGNxM,EAAEhB,EAAIA,EAAI5F,EAAI,EACd4G,EAAEvH,KAGGuG,EAAI,EAAG5F,GAAKoT,EAAIpT,GAAK,EACtB4G,EAAEvH,EAAEuG,IAAMO,EAAE2J,OAAO9P,GACnB4F,GAAK,EAIb,MAAOgB,GASX,QAAS0M,GAAWzM,EAAGD,GACnB,GAAM2M,GAAK3M,EAAEvH,EACPmU,EAAK3M,EAAExH,EACTW,EAAI4G,EAAEL,EACNP,EAAIa,EAAEN,EACNN,EAAIW,EAAEhB,EACNM,EAAIW,EAAEjB,CAGV,KAAK2N,EAAG,KAAOC,EAAG,GAAI,CAClB,GAAI7C,SAMJ,OAFIA,GAHC4C,EAAG,GAGKvT,EAFCwT,EAAG,IAAMxN,EAAH,EAQxB,GAAIhG,IAAMgG,EACN,MAAOhG,EAEX,IAAMyT,GAAOzT,EAAI,CAGjB,IAAIiG,IAAMC,EACN,MAAQD,GAAIC,EAAIuN,EAAM,GAAE,CAQ5B,KANAzT,GAAI,EACJiG,EAAIsN,EAAG1S,OACPqF,EAAIsN,EAAG3S,OACPmF,EAAKC,EAAIC,EAAKD,EAAIC,EAGblG,GAAK,EAAGA,EAAIgG,EAAGhG,GAAK,EACrB,GAAIuT,EAAGvT,KAAOwT,EAAGxT,GACb,MAAQuT,GAAGvT,GAAKwT,EAAGxT,GAAKyT,EAAM,GAAE,CAKxC,IAAI9C,SAOJ,OALIA,GADA1K,IAAMC,EACG,EAECD,EAAIC,EAAIuN,EAAM,GAAE,EAelC,QAASC,GAAUnN,EAAGwH,GAClBxH,EAAIA,EAAEmF,WACNnF,EAAIA,EAAE6E,QAAQ,IAAK,IACnB,IAAMuI,GAAWR,EAASpF,EAASvL,MAC7BoR,EAAWT,EAASpF,EAASxL,MAC7BsR,EAAWV,EAAS5M,GAEtBoK,QACJ,QAAQ5C,EAASzL,SACb,IAAK,QACDqO,GAAU2C,EAAWK,EAAUE,IAAY,GAAI,EAC/C,MACJ,KAAK,UACDlD,IAAU,EAAM2C,EAAWM,EAAUC,GAAY,EACjD,MACJ,KAAK,SACDlD,IAAU,GAAM,EAChB,MACJ,SACIA,GAAU2C,EAAWK,EAAUE,IAAY,EAAIP,EAAWM,EAAUC,GAAY,GAGxF,MAAOlD,GAMX,QAASmD,GAAQ3S,GAWb,MALI8I,GAAS9I,KAETA,MAAUA,EAAIiK,QAAQ,mBAAoB,SAGvCvB,EAAE1I,GAWb,QAAS4S,GAAUC,EAAOjG,GAA0B,GAAhBkG,GAAgBvG,UAAA7M,OAAA,GAAAR,SAAAqN,UAAA,IAAAA,UAAA,GAC5CwG,EAAOF,EAAME,KAAK,cACjBA,KACDA,KACAF,EAAME,KAAK,cAAeA,GAG9B,IAAIjJ,GAASiJ,EAAKjJ,MAMlB,QALKlB,EAAYkB,IAAW8C,GAAakG,KACrChJ,EAAS,GAAIkJ,GAAkBH,EAAMI,IAAI,GAAIrG,GAC7CmG,EAAKjJ,OAASA,GAGXA,EASX,QAASoJ,GAAqBtG,GAC1BA,EAASY,KAAWZ,EAAStL,KAC7BsL,EAASuG,KAAWvG,EAAS/K,KAC7B+K,EAASwG,SAAWxG,EAAS9K,SAC7B8K,EAASyG,KAAWzG,EAASlM,KAC7BkM,EAAS0G,MAAW1G,EAAS7L,MAC7B6L,EAAS2G,QAAW3G,EAAS1L,QAOjC,QAASsS,GAAWC,GAIhB,IAAK,GAHCC,GAASD,EAAO,IAChBE,EAAKpI,SAASqI,OAAOjJ,MAAM,KAC7BzM,EAAI,GACCW,EAAI,EAAGA,EAAI8U,EAAGjU,OAAQb,GAAK,EAAG,CAEnC,IADAX,EAAIyV,EAAG9U,GACgB,MAAhBX,EAAEyQ,OAAO,IACZzQ,EAAIA,EAAEsS,UAAU,EAAGtS,EAAEwB,OAEzB,IAA0B,IAAtBxB,EAAEkM,QAAQsJ,GACV,MAAOxV,GAAEsS,UAAUkD,EAAOhU,OAAQxB,EAAEwB,QAI5C,MAAO,MAMX,QAASmU,KACL,GAAMC,GAAM,WACZ,KAGI,MAFAC,gBAAeC,QAAQF,EAAKA,GAC5BC,eAAeE,WAAWH,IACnB,EACT,MAAOrP,GACL,OAAO,GAOf,QAASyP,GAASvH,EAAOC,EAAUuH,GAC/B,GAAIvH,EAASjL,MAAO,CAChB,GAAMyS,GAAgC,KAAlBzH,EAAM,GAAG8G,MAAgB7K,EAAY+D,EAAM,GAAG8G,MAA/C,QAA4G9G,EAAM,GAAG7O,GAArH,QAA+DuW,mBAAmB1H,EAAM,GAAG8G,MAC1Ga,SACAC,QAGJ,IAAIV,OAAkB,EAClB,OAAQM,GACJ,IAAK,MACD5I,SAASqI,OAAYQ,EAArB,IAAmCxH,EAAS6D,SAA5C,qBACA,MACJ,KAAK,OACD6D,EAAO,GAAIE,MACXF,EAAKG,QAAQH,EAAKI,WAAa,OAC/BH,EAAU,aAAeD,EAAKK,cAC9BpJ,SAASqI,OAAYQ,EAArB,QAAuCG,EAAvC,UACA,MACJ,KAAK,MACD,MAAOf,GAAWY,OAG1B,QAAQD,GACJ,IAAK,MACDJ,eAAeC,QAAQI,EAAYxH,EAAS6D,SAC5C,MACJ,KAAK,OACDsD,eAAeE,WAAWG,EAC1B,MACJ,KAAK,MACD,MAAOL,gBAAea,QAAQR,KAalD,QAASpB,GAAkB9H,EAAM0B,GAC7BpP,KAAKoP,SAAWA,EAChBpP,KAAK0N,KAAOA,EACZ1N,KAAKqV,MAAQnK,EAAEwC,GACf1N,KAAKqX,WAAY,EACjBrX,KAAKwM,cAAgBqD,EAAS7P,KAAKqV,MAAOrV,KAAKoP,UAC/CpP,KAAKiB,MAAQyM,EAAKzM,MAinBtB,QAASqW,MAAiD,GAA/BC,KAA+BxI,UAAA7M,OAAA,GAAAR,SAAAqN,UAAA,KAAAA,UAAA,GAANrB,EAAMqB,UAAA,GAChDI,EAAQgG,EAAQzH,GAChB8J,EAAYtM,EAAE,QAAQuM,MAAMtI,GAC5BuI,EAAkBxM,aAAasM,EAAb,KAA2B,GAC7CG,KAGAC,KAGAC,EAAkB,wCAGlBC,EAAe,qCAGfC,EAAiB,wBACjBC,EAAuB,gJAEzBC,EAAQ,CA0BZ,IAvBA/M,EAAEmE,KAAKqI,EAAiB,SAACrW,EAAG6W,GACL,KAAfA,EAAMjC,OAAe6B,EAAa/E,KAAKmF,EAAMC,YAAeN,EAAgB9E,KAAKmF,EAAME,OAAUF,EAAMG,WAAaH,EAAMI,SAAYP,EAAehF,KAAKmF,EAAME,MAIhKR,EAAQ3V,MAAK,IAHb2V,EAAQ3V,KAAKgW,GACbA,OAORA,EAAQ,EACR/M,EAAEmE,KAAKqI,EAAiB,SAACrW,EAAG6W,GACA,UAApBA,EAAMC,WAAyC,KAAfD,EAAME,MAA8B,SAAfF,EAAME,MAAkC,WAAfF,EAAME,MAAoC,QAAfF,EAAME,MAI/GT,EAAQ1V,MAAK,GACW,UAApBiW,EAAMC,WAAyBH,EAAqBjF,KAAKmF,EAAME,OAC/DH,MALJN,EAAQ1V,KAAKgW,GACbA,OASJV,EAAkB,CAClB,GAAMgB,GAAapJ,EAAMqJ,gBAezB,OAbAtN,GAAEmE,KAAKkJ,EAAY,SAAClX,EAAG6W,GACnB,GAAMO,GAAYvN,EAAEwN,QAAQrX,EAAGuW,EAE/B,IAAIa,GAAY,GAAMd,EAAQc,IAAa,EAAI,CAC3C,GAAME,GAAYzN,aAAasM,EAAb,cAAoCG,EAAQc,GAA5C,KACZrJ,EAAWuJ,EAAUpD,KAAK,cAER,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,MACP8I,EAAMjX,MAAQ0X,EAAUpJ,YAAY,gBAAgBxC,eAKzDwL,EAEN,GAAAK,GAAA,WAED,GAAML,GAAapJ,EAAM0J,YACnBC,EAAYP,EAAWpL,MAAM,IAoBnC,OAlBAjC,GAAEmE,KAAKyJ,EAAW,SAAAzX,GAAK,GAAA0X,GACaD,EAAUzX,GAAG8L,MAAM,KADhC6L,EAAA9X,EAAA6X,EAAA,GACZE,EADYD,EAAA,GACD5G,EADC4G,EAAA,GAEbP,EAAYvN,EAAEwN,QAAQrX,EAAGuW,EAG/B,IAAIa,GAAY,GAAMd,EAAQc,IAAa,EAAI,CAC3C,GAAME,GAAYzN,aAAasM,EAAb,cAAoCG,EAAQc,GAA5C,KACZrJ,EAAWuJ,EAAUpD,KAAK,cAEhC,IAAwB,YAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,KACY,OAAfgD,EAAqB,CACrB,GAAM8G,GAAqBP,EAAUpJ,YAAY,gBAAgBxC,UACjE+L,GAAUzX,GAAQ4X,EAAlB,IAA+BC,OAM/CnR,EAAO+Q,EAAUjI,KAAK,QAvBrB,mCAAA+H,GAAA,YAAArW,EAAAqW,IAAA,MAAAA,GAAA7Q,EAkCT,QAASoR,IAAuBhK,EAAO7C,GAoCnC,MAnCA6C,GAAMiK,GAAG,6CAA8C,SAAAnS,GACnDqF,EAAS8I,EAAUjG,EACnB,IAAMkK,GAAY/M,EAAOE,aACzB,IAAe,YAAXvF,EAAEmR,MAAiC,eAAXnR,EAAEmR,OAA0BjJ,EAAMmK,GAAG,WAAkC,UAArBD,EAAU9U,OAAoB,CACxG8U,EAAUhI,OAAQ,EAES,OAAvBgI,EAAU/U,UAAwC,KAAnB+U,EAAUlJ,MACzChB,EAAMG,IAAIiC,EAAgBpC,EAAMG,MAAO+J,GAG3C,IAAIrH,SACAqH,GAAUtV,MACVsV,EAAUvV,KAAOuV,EAAUtV,KAC3BoL,EAAMI,YAAY,MAAO8J,EAAUpG,WAC5BoG,EAAUrV,cACjBqV,EAAUvV,KAAOuV,EAAUrJ,KAC3Bb,EAAMI,YAAY,MAAO8J,EAAUpG,WAC5BoG,EAAUlW,MACjBkW,EAAUnW,KAAO,GACjBmW,EAAU9V,MAAQ,GAClB8V,EAAU3V,QAAU,GACpByL,EAAMI,YAAY,MAAO8J,EAAUpG,YAC3BjB,EAASzF,EAAU4C,EAAMG,MAAO+J,MAAgBA,EAAUpG,UAClE9D,EAAMI,YAAY,MAAOyC,GAG7B1F,EAAOiN,MAAQpK,EAAMG,MACrBhD,EAAOkN,QAAUlN,EAAOiN,KACxB,IAAME,GAAUtH,EAAW7F,EAAOiN,MAAOF,GAAW,EACnC,QAAZI,GAAgC,KAAZA,GAAwC,UAArBJ,EAAU9U,QAClD4K,EAAMG,IAAImK,MAKfnN,EAUX,QAASoN,IAAUvK,EAAO7C,GAsCtB,MArCA6C,GAAMiK,GAAG,sBAAuB,SAAAnS,GAE5B,GADAqF,EAAS8I,EAAUjG,GACf7C,EAAOoB,KAAKiM,SAGZ,MAFArN,GAAOsN,WAAY,GAEZ,CAQX,IADAtN,EAAOuN,KAAK5S,GACRqF,EAAOwN,WAAW7S,GAGlB,MAFAqF,GAAOsN,WAAY,GAEZ,CAEX,IAAItN,EAAOyN,gBAAiB,CACxBzN,EAAOsN,WAAY,EACnBtN,EAAO0N,YAAY/S,EACnB,IAAMgT,GAAe9K,EAAMG,KAS3B,OARK2K,KAAiB3N,EAAOkN,SAAYlN,EAAOE,cAAc0N,YAE1D/K,EAAMgL,QAAQ,SAElB7N,EAAOkN,QAAUS,EACjB3N,EAAOE,cAAc0N,YAAa,EAClCjT,EAAEmT,kBAEK,EAIX,MAFA9N,GAAO+K,WAAY,GAEZ,IAGJ/K,EAUX,QAAS+N,IAAWlL,EAAO7C,GAoCvB,MAnCA6C,GAAMiK,GAAG,uBAAwB,SAAAnS,GAE7B,IAAIA,EAAEqT,UAAYrT,EAAElC,UAAYA,EAAQmB,OAAxC,CAGAoG,EAAS8I,EAAUjG,EACnB,IAAMyK,GAAYtN,EAAOsN,SAGzB,IAFAtN,EAAOuN,KAAK5S,GAERqF,EAAOwN,WAAW7S,GAClB,OAAO,CAGX,IAAI2S,EAGA,MAFA3S,GAAEmT,kBAEK,CAGX,IAAI9N,EAAOyN,iBAAmBzN,EAAOiO,kBAAmB,CACpDjO,EAAO0N,YAAY/S,EACnB,IAAMgT,GAAe9K,EAAMG,KAS3B,OARK2K,KAAiB3N,EAAOkN,SAAYlN,EAAOE,cAAc0N,YAE1D/K,EAAMgL,QAAQ,SAElB7N,EAAOkN,QAAUS,EACjB3N,EAAOE,cAAc0N,YAAa,MAClCjT,GAAEmT,iBAIN9N,EAAO+K,WAAY,KAGhB/K,EAWX,QAASkO,IAAQrL,EAAO7C,EAAQ8C,GA0C5B,MAzCAD,GAAMiK,GAAG,oBAAqB,SAASnS,GACnCqF,EAAS8I,EAAUjG,GACnB7C,EAAOuN,KAAK5S,EACZ,IAAMwT,GAAOnO,EAAOwN,WAAW7S,GACzByT,EAAMpO,EAAOqO,MA2BnB,OA1BArO,GAAOqO,OAAS,QACTrO,GAAOsO,sBAGVzL,EAAM,GAAGlO,QAAUqL,EAAOE,cAAcjJ,MACL,MAA/B+I,EAAOE,cAAchJ,MACrB8K,EAAoBtO,KAAM,EAAG,GAE7BsO,EAAoBtO,KAAMsM,EAAOE,cAAcjJ,MAAMrB,OAAQoK,EAAOE,cAAcjJ,MAAMrB,QAErFwY,IAAQ3V,EAAQE,KACvBqJ,EAAoBtO,KAAM,EAAGmP,EAAMG,MAAMpN,QAGzCiN,EAAM,GAAGlO,QAAUqL,EAAOE,cAAc9I,SACxC4K,EAAoBtO,KAAM,EAAG,GAGK,KAAlCsM,EAAOE,cAAcyG,UAAkD,KAA/B3G,EAAOE,cAAcjJ,OAAiD,KAAjC+I,EAAOE,cAAc9I,SAClG4K,EAAoBtO,KAAM,EAAG,GAIC,OAA9BsM,EAAOE,cAAczI,MAAiBuI,EAAOE,cAAcrI,OAC3DuS,EAASvH,EAAOC,EAAU,SAE1BqL,IAGe,KAAfza,KAAKiB,YAGJqL,EAAO+K,WACR/K,EAAO0N,YAAY/S,OAGpBqF,EAUX,QAASuO,IAAwB1L,EAAO7C,GAgFpC,MA/EA6C,GAAMiK,GAAG,8CAA+C,WACpD,IAAKjK,EAAMmK,GAAG,UAAW,CACrBhN,EAAS8I,EAAUjG,EACnB,IAAIlO,GAAQkO,EAAMG,MACZwL,EAAY7Z,EACZmO,EAAW9C,EAAOE,aAmBxB,IAlBA4C,EAASiC,OAAQ,EACbjC,EAASjL,OACTuS,EAASvH,EAAOC,EAAU,OAG1BA,EAASjM,QAAS,IAClBiM,EAASlM,KAAOkM,EAASyG,KACzBzG,EAAS7L,MAAQ6L,EAAS0G,MAC1B1G,EAAS1L,QAAU0L,EAAS2G,SAGV,OAAlB3G,EAASrL,OACTqL,EAAStL,KAAOsL,EAASY,KACzBZ,EAAS/K,KAAO+K,EAASuG,KACzBvG,EAAS9K,SAAW8K,EAASwG,UAGjC3U,EAAQsL,EAAUtL,EAAOmO,GACX,KAAVnO,EAAc,CACVmO,EAASuB,mBACT1P,EAAQ,IAAMA,EACdmO,EAASuB,kBAAmB,EAHlB,IAAAoK,GAMahG,EAAU9T,EAAOmO,GAN9B4L,EAAA9Z,EAAA6Z,EAAA,GAMPE,EANOD,EAAA,GAMEE,EANFF,EAAA,EAO6B,QAAvC7I,EAAWlR,EAAOmO,GAAU,IAAmB6L,GAAWC,GAC1Dja,EAAQgR,EAAUhR,EAAOmO,GACzBA,EAAS6D,SAAWhS,EAEhBmO,EAASpL,eACT/C,GAAgBmO,EAASpL,aACzB/C,EAAQA,EAAM8L,YAGlBqC,EAAStL,KAAQsL,EAASpL,cAAgBoL,EAASnL,cAAiBmL,EAASnL,aAAemL,EAAStL,KACrG7C,EAAQqS,EAAUrS,EAAOmO,GACzBnO,EAAQiR,EAAcjR,EAAOmO,KAExB6L,GACD9L,EAAMgL,QAAQ,2BAEbe,GACD/L,EAAMgL,QAAQ,2BAGlBlZ,EAAQmO,EAAS6D,cAGG,SAApB7D,EAAS7K,QACT6K,EAAS6D,SAAW,IACpBhS,EAAQqS,EAAU,IAAKlE,IAEvBA,EAAS6D,SAAW,EAI5B,IAAIkI,GAAehJ,EAAWlR,EAAOmO,GAAU,EAC1B,QAAjB+L,IACAA,EAAe7I,EAAUrR,EAAOmO,IAGhC+L,IAAiBL,IACjBK,EAAgB/L,EAASlL,YAAeiX,EAAe/L,EAASlL,YAAciX,EAC9EhM,EAAMG,IAAI6L,IAGVA,IAAiB7O,EAAOiN,QACxBpK,EAAMiM,eACC9O,GAAOiN,UAKnBjN,EAUX,QAAS+O,IAAQlM,EAAO7C,GA0BpB,MAzBA6C,GAAMiK,GAAG,QAAS,SAASnS,GAEvBA,EAAEmT,iBACF9N,EAAS8I,EAAUjG,EAEnB,IAAMmM,GAAcnM,EAAMI,YAAY,OAChC0K,EAAeja,KAAKiB,OAAS,GAC7B2M,EAAiB5N,KAAK4N,gBAAkB,EACxCS,EAAerO,KAAKqO,cAAgB,EACpCkN,EAAStB,EAAajH,UAAU,EAAGpF,GACnC4N,EAASvB,EAAajH,UAAU3E,EAAc4L,EAAa/X,QAC3DuZ,EAAapP,EAAkBpF,EAAEyU,cAAcC,cAAcC,QAAQ,cAAetP,EAE1F,IAAIJ,EAAiBuP,GAAa,CAC9B,GAAMI,GAAWxP,EAAkBkP,EAAStL,OAAOwL,GAAYK,UAAYN,EAAQlP,EAE/EJ,GAAiB2P,IAAa5L,OAAOqL,GAAaQ,YAAc7L,OAAO4L,GAAUC,YACjF3M,EAAMI,YAAY,MAAOsM,GACzB1M,EAAMgL,QAAQ,cAGlBna,MAAK4N,eAAiBS,IAIvB/B,EAUX,QAASyP,IAAS5M,EAAO7C,GAarB,MAZA6C,GAAM6M,QAAQ,QAAQ5C,GAAG,qBAAsB,WAG3C,GAFA9M,EAAS8I,EAAUjG,GAEP,CACR,GAAMkK,GAAY/M,EAAOE,aAErB6M,GAAUzU,eACVuK,EAAMG,IAAI+J,EAAUpG,aAKzB3G,EASX,QAAS2P,IAA8B9M,GAEnC,GAAM+M,GAAS/M,EAAMmK,GAAG,2EAGnB4C,IAAkD,UAAxC/M,EAAMnD,KAAK,WAAWJ,eACjC+C,qBAA8BQ,EAAMnD,KAAK,QAAzC,oCAIJ,IAAMmQ,GAAoBhN,EAAMnD,KAAK,WAAWJ,aAKhD,OAJ0B,UAAtBuQ,GAAkCtP,EAAUsP,EAAmBnZ,IAC/D2L,UAAmBwN,EAAnB,yCAGGD,EAUX,QAASE,IAA6BhN,EAAU8M,EAAQ/M,GACpD,GAAIkN,IAAW,CAEf,IAAIH,EAAQ,CACR,GAAMjC,GAAe9K,EAAMG,KAa3B,IAAIF,EAAS3K,OAA0B,KAAjBwV,GAAuB5O,EAAyB8D,EAAMmN,KAAK,UAAW,CAExF,GAAMC,GAAqBC,WAAWvC,EAAaxN,QAAQ,IAAK,KAE3DL,OAAMmQ,IAAuBE,MAAaF,EAK3C5N,gBAAyBsL,EAAzB,wEAJA9K,EAAMI,YAAY,MAAOgN,GACzBF,GAAW,OAaf,IAA4B,OAAvBjN,EAASzK,WAAsByK,EAASzK,UAAUoI,aAAekN,GAC1C,OAAvB7K,EAASzK,WAAuC,KAAjBsV,GAAuBA,IAAiB9K,EAAMmN,KAAK,UACjE,KAAjBrC,GAA8C,WAAvB9K,EAAMmN,KAAK,UAAyBpR,EAAEwR,UAAUzC,EAAaxN,QAAQ,IAAK,MAAQ,CAO1G,IANuB,OAAlB2C,EAASrL,MAAiBqL,EAASjL,OACnCiL,EAASpL,cAAgBoL,EAASjL,SACnCiL,EAAS6D,SAAWyD,EAASvH,EAAOC,EAAU,SAI7CA,EAASjL,MAAO,CACjB,GAAIwY,SAEsB,QAAtBvN,EAAS9K,UAAuC,KAAlB8K,EAASe,MACvCf,EAASiC,OAAQ,EACjBsL,EAAUpL,EAAgB0I,EAAc7K,IAExCuN,EAAU1C,EAGd7K,EAAS6D,UAA+B,MAAlB7D,EAAS3L,MAAoC,MAAnB2L,EAAS5L,OAAmC,MAAlB4L,EAAS3L,OAAoC,KAAlB2L,EAASe,MAAezD,EAASuN,EAAc,KAAM,IAAM1N,EAAUoQ,EAASvN,GAAU7C,EAAUoQ,EAASvN,GAGpNiN,GAAW,EAInB,GAAqB,KAAjBpC,EACA,OAAQ7K,EAAS7K,QACb,IAAK,QACD8X,GAAW,CACX,MACJ,KAAK,SACDlN,EAAMG,IAAIF,EAAS7L,OACnB8Y,GAAW,CACX,MACJ,KAAK,OACDlN,EAAMI,YAAY,MAAO,KACzB8M,GAAW,MAKZA,IAAYpC,IAAiB9K,EAAMmN,KAAK,UAC/CnN,EAAMI,YAAY,MAAO0K,GAI7BpN,EAAUsC,EAAMnD,KAAK,WAAWJ,cAAewD,EAASwN,UAA6B,KAAjBzN,EAAMhD,SAC/C,OAAvBiD,EAASzK,UACLyK,EAASzK,YAAcwK,EAAMhD,QAC7BgD,EAAMI,YAAY,MAAOJ,EAAMhD,QAGnCgD,EAAMI,YAAY,MAAOJ,EAAMhD,SAgB3C,QAAS0Q,IAAkBC,EAAS1N,GAChC,IAAKhE,EAAY0R,IAAYzR,EAAyByR,EAAQrZ,OAA2B,KAAlBqZ,EAAQvZ,MAC3E,OAAQ6L,EAAS5L,OACb,IAAK,IACD4L,EAAS3L,KAAO,GAChB,MACJ,KAAK,IACD2L,EAAS3L,KAAO,KAgBhC,QAASsZ,IAAmBD,EAAS3N,GAEjC,GAAIC,GAAWD,EAAMoG,KAAK,cAG1B,IAAwB,YAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,IAAuB,CAE9B,GAAM4N,GAAU7N,EAAMoG,MAuCtB,OArCAnG,GAAWlE,EAAE+R,UAAWha,EAAiB+Z,EAASF,GAC9CzL,OAAkB,EAClB6L,SAAkB,EAClBjK,SAAkB,GAClBtC,kBAAkB,EAClBwM,UAAkB,EAClBjD,YAAkB,EAClB3H,OAAkB,EAClBqK,QAAkB5Z,IAItBkI,EAAEmE,KAAKD,EAAU,SAACgO,EAAKnc,GAEL,SAAVA,GAA8B,UAAVA,IACpBmO,EAASgO,GAAiB,SAAVnc,GAKC,gBAAVA,IAA8B,WAARmc,IAC7BhO,EAASgO,GAAOnc,EAAM8L,cAK9B8P,GAAkBC,EAAS1N,GAG3BA,EAASe,KAAOf,EAASvL,KAAO,EAAI,IAAM,GAG1Cf,EAASsM,GAAU,GAGnBD,EAAMoG,KAAK,cAAenG,GAEnBA,EAEP,MAAO,MA6rBf,QAASiO,IAAkBC,EAAWC,GAClC,MAAO,IAAIC,aAAYF,GAAaC,SAAQE,SAAS,EAAOC,YAAY,IAU5E,QAASC,IAAgBL,GAA0B,GAAfC,GAAexO,UAAA7M,OAAA,GAAAR,SAAAqN,UAAA,GAAAA,UAAA,GAAN,IACzC,OAAOhB,UAAS6P,cAAcP,GAAkBC,EAAWC,IAt7D/D/H,EAAkB9S,WACdmX,KAD0B,SACrB5S,GACDjH,KAAKiB,MAAQjB,KAAK0N,KAAKzM,MACvBjB,KAAKwM,cAAgBqD,EAAS7P,KAAKqV,MAAOrV,KAAKoP,UAC/CpP,KAAK6d,QAAU5W,EAAE4W,QACjB7d,KAAK8d,OAAS7W,EAAE8W,QAChB/d,KAAKsa,SAAWrT,EAAEqT,SAGlBta,KAAKgO,UAAYP,EAAoBzN,KAAK0N,MAC3B,YAAXzG,EAAEmR,MAAiC,UAAXnR,EAAEmR,OAC1BpY,KAAK2a,OAAS1T,EAAElC,SAEpB/E,KAAKge,MAAQ/W,EAAE+W,MACfhe,KAAK4Z,WAAY,EACjB5Z,KAAKqX,WAAY,GAGrB4G,aAlB0B,SAkBb7P,EAAOD,EAAK+P,GACrB9P,EAAQuB,KAAKC,IAAIxB,EAAO,GACxBD,EAAMwB,KAAKwO,IAAIhQ,EAAKnO,KAAK0N,KAAKzM,MAAMiB,QACpClC,KAAKgO,WACDI,QACAD,MACAjM,OAAQiM,EAAMC,IAEdhD,EAAY8S,IAAYA,IACxB5P,EAAoBtO,KAAK0N,KAAMU,EAAOD,IAI9CiQ,YA/B0B,SA+BdC,EAAKH,GACble,KAAKie,aAAaI,EAAKA,EAAKH,IAGhCI,eAnC0B,WAoCtB,GAAMrd,GAAQjB,KAAKiB,MACbsd,EAAOtd,EAAM+R,UAAU,EAAGhT,KAAKgO,UAAUI,OACzCoQ,EAAQvd,EAAM+R,UAAUhT,KAAKgO,UAAUG,IAAKlN,EAAMiB,OAExD,QAAQqc,EAAMC,IAGlBC,sBA3C0B,WA4CtB,GAAMjS,GAAgBxM,KAAKwM,cADPkS,EAEA1e,KAAKse,iBAFLK,EAAAzd,EAAAwd,EAAA,GAEfH,EAFeI,EAAA,GAETH,EAFSG,EAAA,EAWpB,OARAJ,GAAOhS,EAAUgS,EAAMve,KAAKwM,eAC5BgS,EAAQjS,EAAUiS,EAAOxe,KAAKwM,eAC1BA,EAAcmE,mBAAqBjE,EAAS6R,EAAM,OAClDA,EAAO,IAAMA,EACbC,EAAmB,MAAVA,EAAiB,GAAKA,GAEnChS,EAAcmE,kBAAmB,GAEzB4N,EAAMC,IAMlBI,eA5D0B,SA4DXL,EAAMC,GACjB,GAAMhS,GAAgBxM,KAAKwM,aAmB3B,IAhBA+R,EAAOhS,EAAUgS,EAAM/R,GAGvBgS,EAAQjS,EAAUiS,EAAOhS,GACrBA,EAAcmE,mBAAqBjE,EAAS6R,EAAM,OAClDA,EAAO,IAAMA,EACb/R,EAAcmE,kBAAmB,GAEvB,KAAT4N,GAAeA,IAAS/R,EAAc2D,MAAiC,SAAxB3D,EAAchI,OAC1Dga,EAAQ,KACRA,EAAQA,EAAM/R,QAAQ,UAAW,OAKzCzM,KAAK6b,SAAW0C,EAAOC,EACnBhS,EAAcnJ,KAAM,CACpB,GAAM5C,GAAIT,KAAK6b,SAASjL,MAAM,GAAIN,QAAJ,IAAe9D,EAAc4D,iBAA7B,KAAkD5D,EAAcnJ,MAC1F5C,KACA8d,EAAOA,EAAK9R,QAAQhM,EAAE,GAAIA,EAAE,GAAK,KACjCT,KAAK6b,SAAW0C,EAAOC,GAI/B,OAAQD,EAAMC,IAMlBK,cA9F0B,SA8FZN,EAAMC,EAAOM,GACvB,GAAMtS,GAAgBxM,KAAKwM,cACrBuS,EAAQ/e,KAAK4e,eAAeL,EAAMC,GAFTQ,EAGJjK,EAAU/U,KAAK6b,SAAUrP,GAHrByS,EAAA/d,EAAA8d,EAAA,GAGxB/D,EAHwBgE,EAAA,GAGf/D,EAHe+D,EAAA,GAI3BtR,EAAWoR,EAAM,GAAG7c,MAGxB,IAFAlC,KAAK6b,SAAWkD,EAAMlO,KAAK,IAEvBoK,GAAWC,EAAS,CACpBlb,KAAK6b,SAAW1H,EAAgBnU,KAAK6b,SAAUrP,EAAesS,EAC9D,IAAMI,GAAaxS,EAAS1M,KAAK6b,SAAU,KAAQ7b,KAAK6b,SAASpP,QAAQ,IAAK,KAAOzM,KAAK6b,QAW1F,OAVkB,KAAdqD,GAAoBA,IAAc1S,EAAc2D,KAChD3D,EAAcyG,SAAW,GAEzBzG,EAAcyG,SAAWiM,EAEzBvR,EAAW3N,KAAK6b,SAAS3Z,SACzByL,EAAW3N,KAAK6b,SAAS3Z,QAE7BlC,KAAKiB,MAAQjB,KAAK6b,SAClB7b,KAAKoe,YAAYzQ,GAAU,IACpB,EASX,MANKsN,GAEOC,GACRlb,KAAKqV,MAAM8E,QAAQ,2BAFnBna,KAAKqV,MAAM8E,QAAQ,4BAKhB,GAOXgF,aAlI0B,WAmItB,GAAM3S,GAAgBxM,KAAKwM,cACrBjJ,EAAQiJ,EAAcjJ,MACtBmK,EAAO1N,KAAK0N,IAElB,IAAInK,EAAO,CACP,GAAM6b,GAAW7b,EAAMrB,MACvB,IAA4B,MAAxBsK,EAAchJ,MAAe,CAC7B,GAAM6b,GAAS7S,EAAc2D,MAAQzC,EAAKzM,OAASyM,EAAKzM,MAAMkQ,OAAO,KAAO3E,EAAc2D,IAC1F,OAAOkP,IAAU,EAAGD,EAAW,IAAM,EAAGA,GAE5C,GAAME,GAAW5R,EAAKzM,MAAMiB,MAC5B,QAAQod,EAAWF,EAAUE,GAGjC,OAAQ,KAAM,IAOlBC,sBAxJ0B,SAwJJrB,GAClB,GAAMiB,GAAenf,KAAKmf,eACpBnR,EAAYhO,KAAKgO,SAGnBA,GAAUI,MAAQ+Q,EAAa,IAAMnR,EAAUG,IAAMgR,EAAa,MAE7DnR,EAAUI,MAAQ+Q,EAAa,IAAMnR,EAAUG,IAAMgR,EAAa,KAAOnf,KAAKiB,MAAM+R,UAAUrD,KAAKC,IAAI5B,EAAUI,MAAO+Q,EAAa,IAAKxP,KAAKwO,IAAInQ,EAAUG,IAAKgR,EAAa,KAAKvO,MAAM,SACvL5C,EAAUI,MAAQ+Q,EAAa,GAC/Bnf,KAAKie,aAAajQ,EAAUI,MAAO+Q,EAAa,GAAIjB,GAEpDle,KAAKie,aAAakB,EAAa,GAAInR,EAAUG,IAAK+P,GAItDle,KAAKie,aAAatO,KAAKwO,IAAInQ,EAAUI,MAAO+Q,EAAa,IAAKxP,KAAKC,IAAI5B,EAAUG,IAAKgR,EAAa,IAAKjB,KAQpHsB,WA/K0B,WAgLtB,IAAKpU,EAAYpL,KAAK4a,uBAAwB,CAC1C,GAAM6E,GAAWzf,KAAK4a,sBADoB8E,EAEpB1f,KAAKse,iBAFeqB,EAAAze,EAAAwe,EAAA,GAEnCnB,EAFmCoB,EAAA,GAE7BnB,EAF6BmB,EAAA,SAKnC3f,MAAK4a,qBACZ,IAAMgF,GAAmBrB,EAAKsB,OAAO,EAAGJ,EAAS,GAAGvd,QAAUqK,EAAUgS,EAAKsB,OAAOJ,EAAS,GAAGvd,QAASlC,KAAKwM,cACzGxM,MAAK6e,cAAce,EAAkBpB,EAAO,WAC7Cxe,KAAKiB,MAAQwe,EAAS5O,KAAK,IAC3B7Q,KAAKoe,YAAYqB,EAAS,GAAGvd,QAAQ,MASjD4X,WAlM0B,SAkMf7S,GACP,GAAM0T,GAAS3a,KAAK2a,OACdqD,EAAQhe,KAAKge,MACbH,EAAU7d,KAAK6d,QACfC,EAAS9d,KAAK8d,OAGdxD,EAAWta,KAAKsa,QACtB,KAAMuD,GAAWC,IAAsB,UAAX7W,EAAEmR,OAAqBhN,EAAYpL,KAAK4a,wBAA4BN,GAAYK,IAAW5V,EAAQmB,OAE3H,MADAlG,MAAKwf,cACE,CAIX,IAAK7E,GAAU5V,EAAQsE,IAAMsR,GAAU5V,EAAQiF,KAC1C2Q,GAAU5V,EAAQqD,SAAWuS,GAAU5V,EAAQsD,YAC/CsS,GAAU5V,EAAQE,KAAO0V,EAAS5V,EAAQU,OAC1CkV,EAAS5V,EAAQC,YACP,IAAVgZ,GAAeA,IAAUrD,IAC1BA,IAAW5V,EAAQkF,SACnB0Q,IAAW5V,EAAQmF,YACnByQ,IAAW5V,EAAQmB,QACnByU,IAAW5V,EAAQiG,QACnB,OAAO,CAIX,KAAK6S,GAAWC,IAAWnD,IAAW5V,EAAQ+B,EAAG,CAC7C,GAAI9G,KAAKoP,SAAS1K,QAAS,CACvBuC,EAAEmT,gBACF,IAAMkF,GAAWtf,KAAK0N,KAAKzM,MAAMiB,OAC3Bkd,EAAWpf,KAAKoP,SAAS7L,MAAMrB,OAC/B4d,EAAWpT,EAAS1M,KAAK0N,KAAKzM,MAAO,KAAQ,EAAF,EAC3C8e,EAAa/f,KAAKoP,SAAS1L,QAAQxB,OACnCsB,EAAQxD,KAAKoP,SAAS5L,MACtBC,EAAOzD,KAAKoP,SAAS3L,KAEvB2K,QAEAA,GADU,MAAV5K,EACQ,EAEU,MAATC,GAA2B,IAAXqc,GAAgBV,EAAW,EAAGA,EAAW,EAAEA,CAGxE,IAAIjR,SACJ,IAAc,MAAV3K,EACA2K,EAAMmR,EAAWS,MAEjB,QAAQtc,GACJ,IAAK,IACD0K,EAAMmR,GAAYS,EAAaX,EAC/B,MACJ,KAAK,IACDjR,EAAOiR,EAAW,EAAGE,GAAYF,EAAWU,EAASC,GAAYT,GAAYF,EAAWW,EACxF,MACJ,SACI5R,EAAMmR,GAAYF,EAAWW,GAIzCzR,EAAoBtO,KAAK0N,KAAMU,EAAOD,GAE1C,OAAO,EAIX,IAAK0P,GAAWC,KAAYnD,IAAW5V,EAAQrE,GAAKia,IAAW5V,EAAQgD,GAAK4S,IAAW5V,EAAQkD,GAe3F,MAde,YAAXhB,EAAEmR,MACFpY,KAAKuf,wBAIL5E,IAAW5V,EAAQgD,GAAK4S,IAAW5V,EAAQmB,SAC5B,YAAXe,EAAEmR,MAAiC,aAAXnR,EAAEmR,KACtBhN,EAAYpL,KAAK4a,yBACjB5a,KAAK4a,sBAAwB5a,KAAKse,kBAGtCte,KAAKwf,cAGK,YAAXvY,EAAEmR,MAAiC,aAAXnR,EAAEmR,MAAuBuC,IAAW5V,EAAQrE,CAG/E,IAAImd,GAAWC,EACX,OAAO,CAIX,IAAInD,IAAW5V,EAAQe,WAAa6U,IAAW5V,EAAQiB,WAAY,CAC/D,GAAM9C,GAAOlD,KAAKwM,cAActJ,KAC1BG,EAAOrD,KAAKwM,cAAcnJ,KAC1B2c,EAAYhgB,KAAKgO,UAAUI,MAC3BnN,EAAQjB,KAAK0N,KAAKzM,KAQxB,OAPe,YAAXgG,EAAEmR,MAAuBpY,KAAKsa,WAC1BK,IAAW5V,EAAQe,WAAc7E,EAAMkQ,OAAO6O,EAAY,KAAO9c,GAAQjC,EAAMkQ,OAAO6O,EAAY,KAAO3c,EAElGsX,IAAW5V,EAAQiB,YAAe/E,EAAMkQ,OAAO6O,EAAY,KAAO9c,GAAQjC,EAAMkQ,OAAO6O,EAAY,KAAO3c,GACjHrD,KAAKoe,YAAY4B,EAAY,GAF7BhgB,KAAKoe,YAAY4B,EAAY,KAK9B,EAGX,MAAOrF,IAAU5V,EAAQY,UAAYgV,GAAU5V,EAAQkB,WAM3Dga,gBAhT0B,SAAAC,GAgTK,GAAAC,GAAAjf,EAAAgf,EAAA,GAAd3B,EAAc4B,EAAA,GAAR3B,EAAQ2B,EAAA,GACrB3T,EAAgBxM,KAAKwM,aAyD3B,OAxD4B,MAAxBA,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,OACzB,IAAhBzD,KAAK2a,QACLnO,EAAc2Q,SAAYnd,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAc9I,UAAsC,KAA1B8I,EAAc9I,QACzD,MAAhD1D,KAAKiB,MAAMkQ,OAAOnR,KAAKgO,UAAUI,MAAQ,GACzCmQ,EAAOA,EAAKvL,UAAU,GACfhT,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAMiB,OAASsK,EAAc9I,QAAQxB,SACzEqc,EAAOA,EAAKvL,UAAU,EAAGuL,EAAKrc,OAAS,MAG3CsK,EAAc2Q,SAAYnd,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAc9I,UAAsC,KAA1B8I,EAAc9I,QACzG1D,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAcjJ,OAASiJ,EAAcjJ,MAAMrB,SACtFsc,EAAQA,EAAMxL,UAAU,EAAGwL,EAAMtc,SAEjCwK,EAAS6R,EAAM,MAAoD,MAA5Cve,KAAKiB,MAAMkQ,OAAOnR,KAAKgO,UAAUI,SACxDmQ,EAAOA,EAAKvL,UAAU,MAKN,MAAxBxG,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,OAC7C+I,EAAc2Q,SAAYnd,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,MAAQ3D,EAAc2D,KAAKjO,OAC1F,IAAhBlC,KAAK2a,OACD3a,KAAKgO,UAAUI,QAAWpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,MAAQ3D,EAAc2D,KAAKjO,QAAWwK,EAAS1M,KAAKiB,MAAOuL,EAAc2D,MACpIoO,EAAOA,EAAKvL,UAAU,GACN,MAATuL,IAAkBve,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,QAAWzD,EAAS1M,KAAKiB,MAAOuL,EAAc2D,SAChIoO,EAAOA,EAAKvL,UAAU,EAAGuL,EAAKrc,OAAS,KAG3B,MAAZqc,EAAK,KACLC,EAAQA,EAAMxL,UAAU,IAExBhT,KAAKgO,UAAUI,QAAUpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,OAASzD,EAAS1M,KAAKiB,MAAOuL,EAAc2D,QACtGoO,EAAOA,EAAKvL,UAAU,MAKN,MAAxBxG,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,OAC7C+I,EAAc2Q,SAAYnd,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,MAAQ3D,EAAc2D,KAAKjO,OAC1F,IAAhBlC,KAAK2a,OACD3a,KAAKgO,UAAUI,QAAWpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,MAAQ3D,EAAc2D,KAAKjO,OACtFqc,EAAOA,EAAKvL,UAAU,GACN,MAATuL,GAAgBve,KAAKgO,UAAUI,OAAUpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,MAAQ3D,EAAcjJ,MAAMrB,OAC7Gqc,EAAOA,EAAKvL,UAAU,EAAGuL,EAAKrc,OAAS,GACvB,KAATqc,GAAgB7R,EAAS1M,KAAKiB,MAAOuL,EAAc2D,QAC1DoO,EAAOA,EAAKvL,UAAU,EAAGuL,EAAKrc,OAAS,KAG3CsK,EAAc2Q,SAAYnd,KAAKgO,UAAUI,OAASpO,KAAKiB,MAAM2L,QAAQJ,EAAcjJ,QAAkC,KAAxBiJ,EAAcjJ,MACvGvD,KAAKgO,UAAUI,QAAUpO,KAAKiB,MAAM2L,QAAQJ,EAAc2D,QAC1DoO,EAAOA,EAAKvL,UAAU,IAE1BwL,EAAQA,EAAMxL,UAAU,MAIxBuL,EAAMC,IAOlBzE,cAjX0B,WAkXtB,GAAMvN,GAAgBxM,KAAKwM,aAC3B,IAAIxM,KAAK2a,SAAW5V,EAAQC,WAAahF,KAAK2a,SAAW5V,EAAQoB,OAAQ,CACrE,GAAIoY,UACAC,QAEJ,IAAKxe,KAAKgO,UAAU9L,OAkBb,CACHlC,KAAKuf,uBAAsB,EADxB,IAAAa,GAEapgB,KAAKye,wBAFlB4B,EAAAnf,EAAAkf,EAAA,EAEF7B,GAFE8B,EAAA,GAEI7B,EAFJ6B,EAAA,GAGHrgB,KAAK6e,cAAcN,EAAMC,OArBD,IAAA8B,GACRtgB,KAAKye,wBADG8B,EAAArf,EAAAof,EAAA,EAMxB,IALC/B,EADuBgC,EAAA,GACjB/B,EADiB+B,EAAA,GAEX,KAAThC,GAAyB,KAAVC,IACfhS,EAAc0N,YAAa,IAGD,MAAxB1N,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAClB,MAAxB+I,EAAchJ,QAAyC,MAAvBgJ,EAAc/I,MAAuC,MAAvB+I,EAAc/I,QAC7EiJ,EAAS1M,KAAKiB,MAAO,KAAM,IAAAuf,GACfxgB,KAAKigB,iBAAiB1B,EAAMC,IADbiC,EAAAvf,EAAAsf,EAAA,EAC9BjC,GAD8BkC,EAAA,GACxBjC,EADwBiC,EAAA,OAGX,KAAhBzgB,KAAK2a,OACL4D,EAAOA,EAAKvL,UAAU,EAAGuL,EAAKrc,OAAS,GAEvCsc,EAAQA,EAAMxL,UAAU,EAAGwL,EAAMtc,OAGzClC,MAAK6e,cAAcN,EAAMC,GAO7B,OAAO,EAGX,OAAO,GAOXjE,gBAzZ0B,WA0ZtB,GAAM/N,GAAgBxM,KAAKwM,cACrBkU,EAAQlV,OAAOmV,aAAa3gB,KAAKge,OAFzB4C,EAGM5gB,KAAKye,wBAHXoC,EAAA3f,EAAA0f,EAAA,GAGTrC,EAHSsC,EAAA,GAGHrC,EAHGqC,EAAA,EAQd,OAJArU,GAAc0N,YAAa,EAIvBwG,IAAUlU,EAAcnJ,MAASmJ,EAAclJ,QAAUod,IAAUlU,EAAclJ,SAAuB,MAAVod,GAA2B,MAAVA,IAAkB1gB,KAAK2a,SAAW5V,EAAQoE,WACpJqD,EAAc1I,OAAS0I,EAAcnJ,UAKtCmJ,EAAc2D,OAAQzD,EAAS8R,EAAOhS,EAAc2D,WAKpDzD,EAAS6R,EAAM/R,EAAcnJ,QAG7Bmb,EAAM5R,QAAQJ,EAAcnJ,MAAQ,IAGE,IAAtCmb,EAAM5R,QAAQJ,EAAcnJ,QAC5Bmb,EAAQA,EAAMqB,OAAO,IAEzB7f,KAAK6e,cAAcN,EAAO/R,EAAcnJ,KAAMmb,EAAO,OAE9C,MAII,MAAVkC,GAA2B,MAAVA,GAAyC,MAAvBlU,EAAc2D,KAqClDuQ,GAAS,KAAOA,GAAS,KACrBlU,EAAc2D,MAAiB,KAAToO,GAAe7R,EAAS8R,EAAOhS,EAAc2D,QACnEoO,EAAO/R,EAAc2D,KACrBqO,EAAQA,EAAMxL,UAAU,EAAGwL,EAAMtc,SAEjCsK,EAAc5I,MAAQ,GAAK4I,EAAc3I,KAAO2I,EAAc5I,OAAS8I,EAAS1M,KAAKiB,MAAOuL,EAAc2D,OAAmB,MAAVuQ,IACnHnC,EAAO/R,EAAc2D,KAAOoO,GAEhCve,KAAK6e,cAAcN,EAAOmC,EAAOlC,EAAO,OACjC,IAIXhS,EAAc0N,YAAa,GAEpB,IAnDE1N,IAKwB,MAAxBA,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAA0C,MAAxB+I,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAChG,KAAT8a,GAAe7R,EAAS8R,EAAOhS,EAAc2D,QAC7CoO,EAAO/R,EAAc2D,KACrBqO,EAAQA,EAAMxL,UAAU,EAAGwL,EAAMtc,SAKjCqc,EADmB,MAAnBA,EAAKpN,OAAO,IAAczE,EAAS6R,EAAM/R,EAAc2D,MAChDoO,EAAKvL,UAAU,EAAGuL,EAAKrc,QAEZ,MAAVwe,EAAiBlU,EAAc2D,KAAOoO,EAAOA,IAG5C,KAATA,GAAe7R,EAAS8R,EAAOhS,EAAc2D,QAC7CoO,EAAO/R,EAAc2D,KACrBqO,EAAQA,EAAMxL,UAAU,EAAGwL,EAAMtc,SAKjCqc,EADAA,EAAKpN,OAAO,KAAO3E,EAAc2D,KAC1BoO,EAAKvL,UAAU,EAAGuL,EAAKrc,QAEZ,MAAVwe,EAAiBlU,EAAc2D,KAAOoO,EAAOA,GAG7Dve,KAAK6e,cAAcN,EAAMC,EAAO,OAEzB,IAyBfxE,YArf0B,SAqfd/S,GAAG,GAAA6Z,GAAA9gB,KACLwM,EAAgBxM,KAAKwM,cACrBuU,EAAa/gB,KAAKiB,MAClB+f,EAAS/Z,EAAElC,QAHNkc,EAIEjhB,KAAKye,wBAJPyC,EAAAhgB,EAAA+f,EAAA,GAIN1C,EAJM2C,EAAA,EAOX,KAA6B,KAAxB1U,EAActJ,MAAwC,KAAvBsJ,EAActJ,OAAiBwJ,EAASqU,EAAYvU,EAActJ,SACzE,KAAxBsJ,EAAcjJ,OAAyC,KAAxBiJ,EAAcjJ,QAAiBmJ,EAASqU,EAAYvU,EAAcjJ,QAAU,IAAA4d,GAC3FJ,EAAW5T,MAAMX,EAAcnJ,MAD4D+d,EAAAlgB,EAAAigB,EAAA,GACvGE,EADuGD,EAAA,GAExGtQ,EAAQ,EACRpE,GAAS2U,EAAU,OACnBvQ,EAAQ,IACRuQ,EAAWA,EAAS5U,QAAQ,IAAK,IACjC8R,EAAOA,EAAK9R,QAAQ,IAAK,KAIf,KAAVqE,GAAgBuQ,EAASnf,OAASsK,EAAcsD,SAA8B,MAAnByO,EAAKpN,OAAO,KACvEoN,EAAOA,EAAKnN,MAAM,IAIR,MAAVN,GAAiBuQ,EAASnf,OAASsK,EAAcuD,SAA8B,MAAnBwO,EAAKpN,OAAO,KACxEoN,EAAOA,EAAKnN,MAAM,IAEtBmN,EAAOzN,EAAQyN,EAGnB,GAAMtd,GAAQqR,EAAUtS,KAAKiB,MAAOjB,KAAKwM,eACrCmB,EAAW1M,EAAMiB,MACrB,IAAIjB,EAAO,CAEP,GAAMqgB,GAAS/C,EAAKpR,MAAM,KAGE,MAAvBX,EAAc/I,MAAyC,MAAxB+I,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,OAAgC,MAAd6d,EAAO,IAAqC,KAAvB9U,EAAc2D,OAClImR,EAAOC,QACqB,MAAxB/U,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAAiBud,IAAWjc,EAAQC,WAAahF,KAAK2a,SAAW5V,EAAQC,WAAagc,IAAWjc,EAAQoB,QAAUnG,KAAK2a,SAAW5V,EAAQoB,SAAWqG,EAAc2Q,WACjNmE,EAAOrf,KAAK,KACZuK,EAAc2Q,SAAsB,YAAXlW,EAAEmR,MAEH,MAAxB5L,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAAiBud,IAAWjc,EAAQC,WAAahF,KAAK2a,SAAW5V,EAAQC,WAAagc,IAAWjc,EAAQoB,QAAUnG,KAAK2a,SAAW5V,EAAQoB,SAAWqG,EAAc2Q,WACjNmE,EAAOrf,KAAK,KACZuK,EAAc2Q,SAAsB,YAAXlW,EAAEmR,MAEH,MAAxB5L,EAAchJ,OAAwC,MAAvBgJ,EAAc/I,MAAiBud,IAAWjc,EAAQC,WAAahF,KAAK2a,SAAW5V,EAAQC,WAAagc,IAAWjc,EAAQoB,QAAUnG,KAAK2a,SAAW5V,EAAQoB,SAAWqG,EAAc2Q,WAAU,WAC3N,GAAMqE,GAAYhV,EAAcjJ,MAAM4J,MAAM,IACtCsU,GAAa,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAChEC,IACNxW,GAAEmE,KAAKmS,EAAW,SAACngB,EAAGsgB,GAClBA,EAAYH,EAAUngB,GAClBwL,EAAU8U,EAAWF,GACrBC,EAAazf,KAAK,KAAO0f,GAEzBD,EAAazf,KAAK0f,KAGtBX,IAAWjc,EAAQC,WAAa8b,EAAKnG,SAAW5V,EAAQC,WACxD0c,EAAazf,KAAK,KAItBqf,EAAOrf,KAAKyf,EAAa7Q,KAAK,KAC9BrE,EAAc2Q,SAAsB,YAAXlW,EAAEmR,QAInC,KAAK,GAAI/W,GAAI,EAAGA,EAAIigB,EAAOpf,OAAQb,IAC1BigB,EAAOjgB,GAAGuP,MAAM,SACjB0Q,EAAOjgB,GAAK,KAAOigB,EAAOjgB,GAIlC,IAAMugB,GAAU,GAAItR,QAAO,OAASgR,EAAOzQ,KAAK,QAG1CgR,EAAU5gB,EAAM2P,MAAMgR,EACxBC,IACAlU,EAAWkU,EAAQ,GAAG3f,QAGH,IAAbyL,GAAkB1M,EAAMkQ,OAAO,KAAO3E,EAAc2D,MAAuB,IAAbxC,GAAkB1M,EAAMkQ,OAAO,KAAO3E,EAAc2D,OAAU3D,EAAcjJ,OAAiC,MAAxBiJ,EAAchJ,QAEnKmK,EAAW3N,KAAKwM,cAAcjJ,MAAMrB,QAA8B,MAApBjB,EAAMkQ,OAAO,GAAa,EAAI,MAG5E3E,EAAcjJ,OAAiC,MAAxBiJ,EAAchJ,QAGrCmK,GAAYnB,EAAcjJ,MAAMrB,QAEhCsK,EAAc9I,UAGdiK,GAAYnB,EAAc9I,QAAQxB,SAK9ClC,KAAK0N,KAAKzM,MAAQA,EAClBjB,KAAKoe,YAAYzQ,GACjB3N,KAAKqX,WAAY,GAypBzB,IAAMyK,KAWFjI,KAXY,SAWPiD,GACD,MAAO9c,MAAKqP,KAAK,WACb,GAAMF,GAAQjE,EAAElL,MACVkc,EAASD,GAA8B9M,GAEvCC,EAAW2N,GAAmBD,EAAS3N,EAC7C,IAAIhE,EAAOiE,GACP,MAAOpP,KAIX0V,GAAqBtG,EACrB,IAAI9C,GAAS8I,EAAUjG,EAAOC,EAG9BA,GAAStL,KAAQsL,EAASpL,cAAgBoL,EAASnL,aAAgBmL,EAASnL,aAAemL,EAAStL,KAEhGsL,EAAS8N,WAAY,GAAS9N,EAAS3K,OACvC2X,GAA6BhN,EAAU8M,EAAQ/M,GAGnDC,EAAS8N,SAAU,EAGfhB,IACA5P,EAAS6M,GAAuBhK,EAAO7C,GACvCA,EAASuO,GAAwB1L,EAAO7C,GACxCA,EAASoN,GAAUvK,EAAO7C,GAC1BA,EAAS+N,GAAWlL,EAAO7C,GAC3BA,EAASkO,GAAQrL,EAAO7C,EAAQ8C,GAChC9C,EAAS+O,GAAQlM,EAAO7C,GACxByP,GAAS5M,EAAO7C,OAU5ByV,QApDY,WAqDR,MAAO7W,GAAElL,MAAMqP,KAAK,WAChB,GAAMF,GAAQgG,EAAQnV,MAChBoP,EAAWD,EAAMoG,KAAK,cACJ,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,MACPD,EAAMG,IAAI,IACVoH,EAASvH,EAAOC,EAAU,QAC1BD,EAAM6S,WAAW,eACjB7S,EAAM8S,IAAI,oBAUtBC,KAtEY,WAuER,MAAOhX,GAAElL,MAAMqP,KAAK,WAChB,GAAMF,GAAQgG,EAAQnV,MAChBoP,EAAWD,EAAMoG,KAAK,cACJ,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,MACPD,EAAMG,IAAI,IACVF,EAAS6D,SAAW,GACpByD,EAASvH,EAAOC,EAAU,YAYtCkG,OAzFY,SAyFLwH,GACH,MAAO5R,GAAElL,MAAMqP,KAAK,WAEhB,GAAMF,GAAQgG,EAAQnV,MAClBoP,EAAWD,EAAMoG,KAAK,cAEF,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,KACPT,8EAEJ,IAAM4D,GAAQpD,EAAMI,YAAY,MAkBhC,IAjBAH,EAAWlE,EAAE+R,OAAO7N,EAAU0N,GAE1B1N,EAASpL,eACToL,EAAStL,KAAQsL,EAASnL,aAAgBmL,EAASnL,aAAemL,EAAStL,MAE/E4R,EAAqBtG,GACrBgG,EAAUjG,EAAOC,GAAU,GAEvBA,EAAS/L,OAAS+L,EAASlM,MAC3ByL,8EAAuFS,EAAS/L,KAAhG,mCAAuI+L,EAASlM,KAAhJ,4BAIJ2Z,GAAkBC,EAAS1N,GAE3BD,EAAMoG,KAAK,cAAenG,GAEN,KAAhBD,EAAMG,OAAiC,KAAjBH,EAAMhD,OAC5B,MAAOgD,GAAMI,YAAY,MAAOgD,MAc5C4P,IAnIY,SAmIRtG,GACA,MAAO3Q,GAAElL,MAAMqP,KAAK,WAChB,GAAiB,OAAbwM,IAAqBzQ,EAAYyQ,GAArC,CAKA,GAAM1M,GAAQgG,EAAQnV,MAChBoP,EAAWD,EAAMoG,KAAK,eACtB2G,EAAS/M,EAAMmK,GAAG,4EACpBrY,EAAQ4a,EAAS9O,UASrB,IARwB,YAApB,mBAAOqC,GAAP,YAAA7M,EAAO6M,KACPT,4EAIJ1N,EAAQ2Q,EAAW3Q,IAGdiK,EAAEwR,UAAUzM,OAAOhP,IAEpB,MADA4N,iBAAsB5N,EAAtB,4EACOkO,EAAMG,IAAI,GAGrB,IAAc,KAAVrO,EA6CA,MAAOkO,GAAMG,IAAI,GA7CH,IAAA8S,GACarN,EAAU9T,EAAOmO,GAD9BiT,EAAAnhB,EAAAkhB,EAAA,GACPnH,EADOoH,EAAA,GACEnH,EADFmH,EAAA,EAEd,KAAIpH,IAAWC,EAyBR,CACH9L,EAAS6D,SAAW,GACpByD,EAASvH,EAAOC,EAAU,OAC1B,IAAMkT,GAAiBrhB,CAYvB,OAXAA,GAAQ,GACHga,GACD9L,EAAMgL,QAAQ,2BAGbe,GACD/L,EAAMgL,QAAQ,2BAGlBxL,gBAAyB2T,EAAzB,0CAAiFlT,EAASvL,KAA1F,eAA6GuL,EAASxL,KAAtH,gCAEOuL,EAAMG,IAAI,IAUzB,MAjDY4M,KAAW9M,EAASrL,MAAQqL,EAASpL,gBACrCoL,EAAS6D,SAAWhS,IAIpBib,GAAUrP,EAAUsC,EAAMnD,KAAK,WAAWJ,cAAewD,EAASwN,YAC9DxN,EAASpL,eAAiBoL,EAASiC,QACnCpQ,GAAgBmO,EAASpL,aACzB/C,EAAQA,EAAM8L,WACdqC,EAAStL,KAAQsL,EAASnL,aAAgBmL,EAASnL,aAAemL,EAAStL,MAG/E7C,EAAQqS,EAAUrS,EAAOmO,GACH,OAAlBA,EAASrL,MAA2C,OAA1BqL,EAASpL,eACnCoL,EAAS6D,SAAWhS,GAGxBA,EAAQiR,EAAcjR,EAAOmO,GAC7BnO,EAAQqR,EAAUrR,EAAOmO,IAGzBA,EAASjL,QAAUiL,EAASrL,MAAQqL,EAASpL,eAC7C0S,EAASvH,EAAOC,EAAU,QAuBjCA,EAASiC,OAASjC,EAASlL,cAC5BjD,GAAgBmO,EAASlL,aAGzBgY,EACO/M,EAAMG,IAAIrO,KAGjB4L,EAAUsC,EAAMnD,KAAK,WAAWJ,cAAewD,EAASwN,UACjDzN,EAAMhD,KAAKlL,OAa9BshB,MAjOY,WAkOR,MAAOrX,GAAElL,MAAMqP,KAAK,WAChB,GAAMF,GAAQgG,EAAQnV,MAChBoP,EAAWD,EAAMoG,KAAK;AACJ,YAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,MACPA,EAASiC,OAAQ,EACjBlC,EAAMG,IAAIH,EAAMI,YAAY,qBAUxCiT,MAjPY,WAkPR,MAAOtX,GAAElL,MAAMqP,KAAK,WAChB,GAAMF,GAAQgG,EAAQnV,MAChBoP,EAAWD,EAAMoG,KAAK,cACJ,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,KACPD,EAAMI,YAAY,MAAOJ,EAAMG,UAY3CmG,IAlQY,WAoQR,GAAMtG,GAAQgG,EAAQnV,MAEhBkc,EAAS/M,EAAMmK,GAAG,4EAClBlK,EAAWD,EAAMoG,KAAK,cACJ,aAApB,mBAAOnG,GAAP,YAAA7M,EAAO6M,KACPT,2EAIJ,IAAI1N,GAAQ,EASZ,IARIib,EACAjb,EAAQkO,EAAMsT,GAAG,GAAGnT,MACbzC,EAAUsC,EAAMnD,KAAK,WAAWJ,cAAewD,EAASwN,SAC/D3b,EAAQkO,EAAMsT,GAAG,GAAGtW,OAEpBwC,WAAoBQ,EAAMnD,KAAK,WAAWJ,cAA1C,0CAGAwD,EAASrL,MAAQqL,EAASpL,aAC1B/C,EAAQmO,EAAS6D,aACd,CACH,IAAO,KAAMF,KAAK9R,IAA4B,IAAlBgP,OAAOhP,IAAqC,UAApBmO,EAAS7K,OACzD,MAAO,EAGG,MAAVtD,GAAsC,OAAtBmO,EAAS9K,WACzB8K,EAASiC,OAAQ,EACjBpQ,EAAQsQ,EAAgBtQ,EAAOmO,KAG/BA,EAAS8N,SAAW9N,EAAS3K,SAAU,KACvCxD,EAAQsL,EAAUtL,EAAOmO,IAG7BnO,EAAQgR,EAAUhR,EAAOmO,GAI7B,MAAOnO,IAaXyhB,aAvTY,WAwTR,GAAMvT,GAAQgG,EAAQnV,MAClBiB,EAAQkO,EAAMI,YAAY,OACxBH,EAAWD,EAAMoG,KAAK,cAM5B,OAJsB,KAAlBtF,OAAOhP,IAAmC,SAAnBmO,EAAS5K,QAChCvD,EAAQ,KAGL6Q,EAAS7Q,EAAOmO,EAASvK,aASpC8d,aAzUY,WA+UR,MAJK3iB,MAAKiM,eAAe,MAAU,SAAWjM,MAAK,IAC/C2O,EAAW,wDAGR3O,KAAK,GAAGiB,OAUnB2hB,UAzVY,WA0VR,MAAOtL,KAAkB,EAAOtX,OAUpC6iB,SApWY,WAqWR,MAAOvL,KAAkB,EAAMtX,OAQnC8iB,YA7WY,WA8WR,GAAM3T,GAAQgG,EAAQnV,KAEtB,OAAOmP,GAAMsT,GAAG,GAAGlN,KAAK,gBAQhCrK,GAAE6X,GAAGxT,YAAc,SAASyT,GACxB,GAAIlB,GAAQkB,GAAS,QAAAC,GAAAlU,UAAA7M,OADcghB,EACd9gB,MAAA6gB,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IADcD,EACdC,EAAA,GAAApU,UAAAoU,EACjB,OAAOrB,IAAQkB,GAAQ/X,MAAMjL,KAAMkjB,GAGvC,MAAsB,YAAlB,mBAAOF,GAAP,YAAAzgB,EAAOygB,KAAwBA,MAKnCrU,cAAsBqU,EAAtB,qCAHWlB,GAAQjI,KAAK5O,MAAMjL,MAAOgjB,KAWzCngB,EAAmB,iBAAMI,IAEzBiI,EAAE6X,GAAGxT,YAAY6T,SAAWngB,EAK5BN,EAAa,SAAC1B,EAAO6b,GACjB,GAAI1R,EAAYnK,IAAoB,OAAVA,EACtB,MAAO,KAGX,IAAMmO,GAAWlE,EAAE+R,UAAWha,GAAmBsP,OAAO,GAASuK,EAOjE,IANA7b,EAAQA,EAAM8L,WACd9L,EAAQ2Q,EAAW3Q,GACfgP,OAAOhP,GAAS,IAChBmO,EAASe,KAAO,KAGE,OAAlBf,EAAStL,KAAe,CACxB,GAAMF,GAAOwL,EAASxL,KAAKmJ,WAAWI,MAAM,KACtCtJ,EAASuL,EAASvL,MAA0B,IAAlBuL,EAASvL,KAAmBuL,EAASvL,KAAKkJ,WAAWI,MAAM,OAC3FiC,GAAStL,KAAO0L,EAAU3L,EAAMD,GAfP,GAAAyf,GAiBFtO,EAAU9T,EAAOmO,GAjBfkU,EAAApiB,EAAAmiB,EAAA,GAiBtBpI,EAjBsBqI,EAAA,GAiBbpI,EAjBaoI,EAAA,EA4B7B,OATKrI,IAAYC,IAEbyC,GAAgB,yBAAhB,qBACAhP,gBAAyB1N,EAAzB,0CAAwEmO,EAASvL,KAAjF,eAAoGuL,EAASxL,KAA7G,iCAEJ3C,EAAQqS,EAAUrS,EAAOmO,GACzBnO,EAAQiR,EAAcjR,EAAOmO,GAC7BnO,EAAQqR,EAAUrR,EAAOmO,IAK7BlE,EAAE6X,GAAGpgB,WAAaA,EAKlBC,EAAe,SAAC3B,EAAO6b,GACnB,GAAI1R,EAAYnK,IAAoB,OAAVA,EACtB,MAAO,KAGX,IAAMmO,GAAWlE,EAAE+R,UAAWha,GAAmBsP,OAAO,GAASuK,GAC3DtM,kBAA0BpB,EAAS/L,KACnCkJ,EAAY,GAAI+D,QAAJ,KAAgBE,EAAhB,IAA4B,KAe9C,OAdAvP,GAAQA,EAAM8L,WAEU,MAApB9L,EAAMkQ,OAAO,GACb/B,EAASe,KAAO,IACTf,EAAS9K,UAAY8K,EAAS9K,SAAS6I,MAAM,KAAK,KAAOlM,EAAMkQ,OAAO,KAC7E/B,EAASe,KAAO,IAChBf,EAASiC,OAAQ,EACjBpQ,EAAQsQ,EAAgBtQ,EAAOmO,IAGnCnO,EAAQA,EAAMwL,QAAQF,EAAW,IACjCtL,EAAQA,EAAMwL,QAAQ,IAAK,KAC3BxL,EAAQ6Q,EAAS7Q,EAAOmO,EAASvK,aAKrCqG,EAAE6X,GAAGQ,aAAe3gB,EAapBE,EAAW,SAAC0gB,GAAmD,GAAtCC,KAAsC1U,UAAA7M,OAAA,GAAAR,SAAAqN,UAAA,KAAAA,UAAA,GACrDjK,GAAQ,GAEVuG,EAAyBmY,KAAiB3X,EAAS2X,IAAgBzX,EAAWyX,KAC9E7U,iEAA0E6U,EAA1E,WAIJ,IAAI1G,SAEAA,GADA2G,EACUvY,EAAE+R,UAAWha,EAAiBugB,GAE9BA,CAGd,IAAME,GAAsB,WACtBC,EAA0B,SAE1BC,EAA4C,yBAC5CC,EAA6B,sBAG9BhX,GAAUiQ,EAAQ5Z,MAAO,IAAK,IAAK,IAAK,MACzCyL,4GAAqHmO,EAAQ5Z,KAA7H,YAGCwI,EAAoBoR,EAAQ3Z,OAAUsI,EAAUqR,EAAQ3Z,OACzDwL,4EAAqFmO,EAAQ3Z,KAA7F,YAGCugB,EAAoB3Q,KAAK+J,EAAQ1Z,SAClCuL,gHAAyHmO,EAAQ1Z,OAAjI,YAGCyJ,EAAUiQ,EAAQzZ,MAAO,IAAK,OAC/BsL,0FAAmGmO,EAAQzZ,KAA3G,YAIAyZ,EAAQzZ,OAASyZ,EAAQ5Z,MACzByL,+EAAwFmO,EAAQzZ,KAAhG,wCAA4IyZ,EAAQ5Z,KAApJ,6BAGCiI,EAAO2R,EAAQxZ,SAAYgI,EAASwR,EAAQxZ,SAC7CqL,oGAA6GmO,EAAQxZ,OAArH,YAGkB,KAAlBwZ,EAAQvZ,OAAiB+H,EAASwR,EAAQvZ,QAC1CoL,6EAAsFmO,EAAQvZ,MAA9F,YAGCsJ,EAAUiQ,EAAQtZ,OAAQ,IAAK,OAChCmL,uHAAgImO,EAAQtZ,MAAxI,YAGCqJ,EAAUiQ,EAAQrZ,MAAO,IAAK,IAAK,IAAK,OACzCkL,+IAAwJmO,EAAQrZ,KAAhK,cAGC6H,EAASwR,EAAQpZ,UAAiC,KAApBoZ,EAAQpZ,UAAmBgJ,EAASoQ,EAAQpZ,QAAS,MAAQigB,EAAwB5Q,KAAK+J,EAAQpZ,YACjIiL,qIAA8ImO,EAAQpZ,QAAtJ,YAGCyH,EAAO2R,EAAQnZ,UAAakJ,EAAUiQ,EAAQnZ,SAAU,UAAW,QAAS,YAC7EgL,sHAA+HmO,EAAQnZ,QAAvI,YAGC2H,EAASwR,EAAQlZ,OAAUggB,EAA0C7Q,KAAK+J,EAAQlZ,OACnF+K,iIAA0ImO,EAAQlZ,KAAlJ,YAGC0H,EAASwR,EAAQjZ,OAAU+f,EAA0C7Q,KAAK+J,EAAQjZ,OACnF8K,iIAA0ImO,EAAQjZ,KAAlJ,YAGA2Y,WAAWM,EAAQjZ,MAAQ2Y,WAAWM,EAAQlZ,OAC9C+K,mGAA4GmO,EAAQjZ,KAApH,oCAA4JiZ,EAAQlZ,KAApK,MAGCuH,EAAO2R,EAAQhZ,OAAWwH,EAASwR,EAAQhZ,OAAU4f,EAAoB3Q,KAAK+J,EAAQhZ,OACvF6K,uGAAgHmO,EAAQhZ,KAAxH,YAGCgZ,EAAQzY,MAAS8G,EAAO2R,EAAQhZ,OACjC+K,yEAA+EiO,EAAQhZ,KAAvF,KAAiGgB,EAIrG,IAAIgf,GAASxW,EAAcwP,EAAQjZ,MAC/BkgB,EAASzW,EAAcwP,EAAQlZ,KACnCkgB,GAAS3Y,EAAO2Y,GAAQ,EAAEA,EAC1BC,EAAS5Y,EAAO4Y,GAAQ,EAAEA,CAC1B,IAAMC,GAAuBrU,KAAKC,IAAIkU,EAAQC,EACzC5Y,GAAO2R,EAAQhZ,QACdmJ,EAAY6P,EAAQjZ,QAASoJ,EAAY6P,EAAQlZ,OAAUogB,IAAyB/T,OAAO6M,EAAQhZ,OACrG+K,wBAA8BiO,EAAQhZ,KAAtC,oDAA8FgZ,EAAQjZ,KAAtG,iBAA2HiZ,EAAQlZ,KAAnI,KAA6IkB,GAG5IqG,EAAO2R,EAAQ/Y,OAAWuH,EAASwR,EAAQ/Y,OAAU2f,EAAoB3Q,KAAK+J,EAAQ/Y,OACvF4K,wGAAiHmO,EAAQ/Y,KAAzH,aAICoH,EAAO2R,EAAQ/Y,QAAUoH,EAAO2R,EAAQhZ,OAASmM,OAAO6M,EAAQhZ,MAAQmM,OAAO6M,EAAQ/Y,OACxF4K,qFAA8FmO,EAAQ/Y,KAAtG,iCAA2I+Y,EAAQhZ,KAAnJ,YAGCqH,EAAO2R,EAAQ9Y,eAAkB6f,EAA2B9Q,KAAK+J,EAAQ9Y,eAC1E2K,kHAA2HmO,EAAQ9Y,aAAnI,YAGCmH,EAAO2R,EAAQ7Y,eAAkByf,EAAoB3Q,KAAK+J,EAAQ7Y,eACnE0K,uGAAgHmO,EAAQ7Y,aAAxH,YAGCkH,EAAO2R,EAAQ5Y,cAAiBoH,EAASwR,EAAQ5Y,cAClDyK,gFAAyFmO,EAAQ5Y,YAAjG,YAGCwH,EAAoBoR,EAAQ3Y,QAAWsH,EAAUqR,EAAQ3Y,QAC1DwK,qGAA8GmO,EAAQ3Y,MAAtH,YAGC0I,EAAUiQ,EAAQ1Y,QACnB,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,MACA,MACA,MACA,SAEAuK,0KAAmLmO,EAAQ1Y,OAA3L,YAGCsH,EAAoBoR,EAAQzY,OAAUoH,EAAUqR,EAAQzY,OACzDsK,oGAA6GmO,EAAQzY,KAArH,YAGC8G,EAAO2R,EAAQxY,WAAcuI,EAAUiQ,EAAQxY,UAAW,MAAO,MAAO,MAAO,SAChFqK,wHAAiImO,EAAQxY,SAAzI,YAGCuI,EAAUiQ,EAAQvY,QAAS,QAAS,QAAS,SAAU,UACxDoK,yHAAkImO,EAAQvY,OAA1I,YAGCsI,EAAUiQ,EAAQtY,OAAQ,QAAS,OAAQ,UAC5CmK,2GAAoHmO,EAAQtY,MAA5H,YAGCkH,EAAoBoR,EAAQrY,QAAWgH,EAAUqR,EAAQrY,QAC1DkK,sGAA+GmO,EAAQrY,MAAvH,YAGCiH,EAAoBoR,EAAQpY,UAAa+G,EAAUqR,EAAQpY,UAC5DiK,kGAA2GmO,EAAQpY,QAAnH,YAGCyG,EAAO2R,EAAQnY,YAAqC,KAAtBmY,EAAQnY,WAAqBif,EAA0C7Q,KAAK+J,EAAQnY,YACnHgK,yIAAkJmO,EAAQnY,UAA1J,YAGC+G,EAAoBoR,EAAQlY,gBAAmB6G,EAAUqR,EAAQlY,gBAClE+J,iHAA0HmO,EAAQlY,cAAlI,YAGCuG,EAAO2R,EAAQjY,aAAgBgI,EAAUiQ,EAAQjY,YAClD,SACA,SACA,IACA,KACA,IACA,KACA,KACA,QAEA8J,kJAA2JmO,EAAQjY,WAAnK,YAGC6G,EAAoBoR,EAAQhY,QAAW2G,EAAUqR,EAAQhY,QAC1D6J,mFAA4FmO,EAAQhY,MAApG,aAIRoG,EAAE6X,GAAGjgB,SAAWA,EAQhBC,EAAmB,SAAS+Z,GACxB,GAAImH,IAAU,CACd,KACInhB,EAASga,GAEb,MAAOoH,GACHD,GAAU,EAGd,MAAOA,IA6BX,WAKI,QAASzG,GAAY2G,EAAOC,GACxBA,EAASA,IAAY3G,SAAS,EAAOC,YAAY,EAAOH,OAAQ,OAChE,IAAM8G,GAAMtW,SAASuW,YAAY,cAEjC,OADAD,GAAIE,gBAAgBJ,EAAOC,EAAO3G,QAAS2G,EAAO1G,WAAY0G,EAAO7G,QAC9D8G,EARX,MAAkC,kBAAvBG,QAAOhH,cAWlBA,EAAY9a,UAAY8hB,OAAOC,MAAM/hB,eACrC8hB,OAAOhH,YAAcA,SFqJ5B7d,EAAQ+kB,SE7ILC,OAAUhiB,EACViiB,SAAUhiB,EACVC,mBACAC,WACAC,sBF+IDvC,KAAKgkB,SAIF,SAAS5kB,EAAQD,GG5oHvBC,EAAAD,QAAAM","file":"autoNumeric.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n\tvar jQuery = __webpack_require__(1);\n\tvar $ = __webpack_require__(1);\n\t(function() {\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t* autoNumeric.js\n\t* @author: Bob Knothe\n\t* @contributors: Sokolov Yura and other Github users\n\t* @version: 2.0 - 2016-12-01 UTC 21:00\n\t*\n\t* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n\t*\n\t* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n\t*\n\t* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n\t*\n\t* Permission is hereby granted, free of charge, to any person\n\t* obtaining a copy of this software and associated documentation\n\t* files (the \"Software\"), to deal in the Software without\n\t* restriction, including without limitation the rights to use,\n\t* copy, modify, merge, publish, distribute, sub license, and/or sell\n\t* copies of the Software, and to permit persons to whom the\n\t* Software is furnished to do so, subject to the following\n\t* conditions:\n\t*\n\t* The above copyright notice and this permission notice shall be\n\t* included in all copies or substantial portions of the Software.\n\t*\n\t* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\t* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\t* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\t* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\t* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\t* OTHER DEALINGS IN THE SOFTWARE.\n\t*/\n\t\n\t/* global module, require, define */\n\t\n\t// Functions names for ES6 exports\n\tvar autoFormat = void 0;\n\tvar autoUnFormat = void 0;\n\tvar getDefaultConfig = void 0;\n\tvar validate = void 0;\n\tvar areSettingsValid = void 0;\n\t\n\t// AutoNumeric default settings\n\t/**\n\t * List of allowed tag on which autoNumeric can be used.\n\t */\n\tvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\t\n\t/**\n\t * Defaults options are public - these can be overridden by the following:\n\t * - HTML5 data attributes\n\t * - Options passed by the 'init' or 'update' methods\n\t * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n\t */\n\tvar defaultSettings = {\n\t    /* Allowed thousand separator characters\n\t     * comma = \",\"\n\t     * period \"full stop\" = \".\"\n\t     * apostrophe is escaped = \"\\\"\"\n\t     * space = \" \"\n\t     * none = \"\"\n\t     * NOTE: do not use numeric characters\n\t     */\n\t    aSep: ',',\n\t\n\t    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n\t     * example if the input value \"$ 1,999.88 suffix\"\n\t     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n\t     */\n\t    nSep: false,\n\t\n\t    /* Digital grouping for the thousand separator used in Format\n\t     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n\t     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n\t     * dGroup: \"3\", results in 999,999,999 default\n\t     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n\t     */\n\t    dGroup: '3',\n\t\n\t    /* Allowed decimal separator characters\n\t     * period \"full stop\" = \".\"\n\t     * comma = \",\"\n\t     */\n\t    aDec: '.',\n\t\n\t    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n\t     * developed for countries the use a comma \",\" as the decimal character\n\t     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n\t     */\n\t    altDec: null,\n\t\n\t    /* aSign = allowed currency symbol\n\t     * Must be in quotes aSign: \"$\"\n\t     * space to the right of the currency symbol aSign: '$ '\n\t     * space to the left of the currency symbol aSign: ' $'\n\t     */\n\t    aSign: '',\n\t\n\t    /* pSign = placement of currency sign as a p=prefix or s=suffix\n\t     * for prefix pSign: \"p\" (default)\n\t     * for suffix pSign: \"s\"\n\t     */\n\t    pSign: 'p',\n\t\n\t    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n\t     * -1,234.56  => default no options required\n\t     * -$1,234.56 => {aSign: \"$\"}\n\t     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n\t     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n\t     * 1,234.56-  => {pNeg: \"s\"}\n\t     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n\t     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n\t     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n\t     */\n\t    pNeg: 'l',\n\t\n\t    /* Additional suffix\n\t     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n\t     * Numeric characters and negative sign not allowed'\n\t     */\n\t    aSuffix: '',\n\t\n\t    /* Override min max limits\n\t     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n\t     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n\t     * oLimits: \"ignore\" ignores both vMin & vMax\n\t     */\n\t    oLimits: null,\n\t\n\t    /* Maximum possible value\n\t     * value must be enclosed in quotes and use the period for the decimal point\n\t     * value must be larger than vMin\n\t     */\n\t    vMax: '9999999999999.99',\n\t\n\t    /* Minimum possible value\n\t     * value must be enclosed in quotes and use the period for the decimal point\n\t     * value must be smaller than vMax\n\t     */\n\t    vMin: '-9999999999999.99',\n\t\n\t    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n\t     * value must be enclosed in quotes example mDec: \"3\",\n\t     */\n\t    mDec: null,\n\t\n\t    /* Expanded decimal places visible when input has focus - example:\n\t     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n\t     * the \"get\" method returns the extended decimal places\n\t     */\n\t    eDec: null,\n\t\n\t    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n\t     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\n\t     * [\"divisor\", \"decimal places\", \"symbol\"]\n\t     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n\t     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n\t     */\n\t\n\t    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n\t     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n\t     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n\t     * The \"get\" method returns the full value, including the 'hidden' decimals.\n\t     */\n\t    scaleDivisor: null,\n\t\n\t    /*\n\t     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n\t     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n\t     */\n\t    scaleDecimal: null,\n\t\n\t    /*\n\t     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n\t     * This is optional too.\n\t     */\n\t    scaleSymbol: null,\n\t\n\t    /* Set to true to allow the eDec value to be saved with sessionStorage\n\t     * if ie 6 or 7 the value will be saved as a session cookie\n\t     */\n\t    aStor: false,\n\t\n\t    /* method used for rounding\n\t     * mRound: \"S\", Round-Half-Up Symmetric (default)\n\t     * mRound: \"A\", Round-Half-Up Asymmetric\n\t     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n\t     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n\t     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n\t     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n\t     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n\t     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n\t     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n\t     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n\t     * mRound: \"U05\" Rounds up to next .05\n\t     * mRound: \"D05\" Rounds down to next .05\n\t     */\n\t    mRound: 'S',\n\t\n\t    /* Controls decimal padding\n\t     * aPad: true - always Pad decimals with zeros\n\t     * aPad: false - does not pad with zeros.\n\t     * Note: setting aPad to 'false' will override the 'mDec' setting.\n\t     *\n\t     * thanks to Jonas Johansson for the suggestion\n\t     */\n\t    aPad: true,\n\t\n\t    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n\t     * Those brackets are visible only when the field does NOT have the focus.\n\t     * The left and right symbols should be enclosed in quotes and separated by a comma\n\t     * nBracket: null - (default)\n\t     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n\t     */\n\t    nBracket: null,\n\t\n\t    /* Displayed on empty string \"\"\n\t     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n\t     * wEmpty: \"press\" - currency sign displays on any key being pressed\n\t     * wEmpty: \"always\" - always displays the currency sign only\n\t     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n\t     */\n\t    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n\t    wEmpty: 'focus',\n\t\n\t    /* Controls leading zero behavior\n\t     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n\t     * lZero: \"deny\", - allows only one leading zero on values less than one\n\t     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n\t     */\n\t    lZero: 'deny',\n\t\n\t    /* Determine if the default value will be formatted on initialization.\n\t     * true = automatically formats the default value on initialization\n\t     * false = will not format the default value\n\t     */\n\t    aForm: true,\n\t\n\t    /* Determine if the select all keyboard command will select\n\t     * the complete input text or only the input numeric value\n\t     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n\t     */\n\t    sNumber: false,\n\t\n\t    /* Helper option for ASP.NET postback\n\t     * should be the value of the unformatted default value\n\t     * examples:\n\t     * no default value=\"\" {anDefault: \"\"}\n\t     * value=1234.56 {anDefault: '1234.56'}\n\t     */\n\t    anDefault: null,\n\t\n\t    /* Removes formatting on submit event\n\t     * this output format: positive nnnn.nn, negative -nnnn.nn\n\t     * review the 'unSet' method for other formats\n\t     */\n\t    unSetOnSubmit: false,\n\t\n\t    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n\t     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n\t     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n\t     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n\t     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n\t     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n\t     */\n\t    outputType: null,\n\t\n\t    /* Error handling function\n\t     * true => all errors are thrown - helpful in site development\n\t     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n\t     */\n\t    debug: false\n\t};\n\t\n\t/**\n\t * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n\t */\n\tvar keyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    PauseBreak: 19,\n\t    CapsLock: 20,\n\t    Esc: 27,\n\t    Space: 32,\n\t    PageUp: 33,\n\t    PageDown: 34,\n\t    End: 35,\n\t    Home: 36,\n\t    LeftArrow: 37,\n\t    UpArrow: 38,\n\t    RightArrow: 39,\n\t    DownArrow: 40,\n\t    Insert: 45,\n\t    Delete: 46,\n\t    num0: 48,\n\t    num1: 49,\n\t    num2: 50,\n\t    num3: 51,\n\t    num4: 52,\n\t    num5: 53,\n\t    num6: 54,\n\t    num7: 55,\n\t    num8: 56,\n\t    num9: 57,\n\t    a: 65,\n\t    b: 66,\n\t    c: 67,\n\t    d: 68,\n\t    e: 69,\n\t    f: 70,\n\t    g: 71,\n\t    h: 72,\n\t    i: 73,\n\t    j: 74,\n\t    k: 75,\n\t    l: 76,\n\t    m: 77,\n\t    n: 78,\n\t    o: 79,\n\t    p: 80,\n\t    q: 81,\n\t    r: 82,\n\t    s: 83,\n\t    t: 84,\n\t    u: 85,\n\t    v: 86,\n\t    w: 87,\n\t    x: 88,\n\t    y: 89,\n\t    z: 90,\n\t    Windows: 91,\n\t    RightClick: 93,\n\t    numpad0: 96,\n\t    numpad1: 97,\n\t    numpad2: 98,\n\t    numpad3: 99,\n\t    numpad4: 100,\n\t    numpad5: 101,\n\t    numpad6: 102,\n\t    numpad7: 103,\n\t    numpad8: 104,\n\t    numpad9: 105,\n\t    MultiplyNumpad: 106,\n\t    PlusNumpad: 107,\n\t    MinusNumpad: 109,\n\t    DotNumpad: 110,\n\t    SlashNumpad: 111,\n\t    F1: 112,\n\t    F2: 113,\n\t    F3: 114,\n\t    F4: 115,\n\t    F5: 116,\n\t    F6: 117,\n\t    F7: 118,\n\t    F8: 119,\n\t    F9: 120,\n\t    F10: 121,\n\t    F11: 122,\n\t    F12: 123,\n\t    NumLock: 144,\n\t    ScrollLock: 145,\n\t    MyComputer: 182,\n\t    MyCalculator: 183,\n\t    Semicolon: 186,\n\t    Equal: 187,\n\t    Comma: 188,\n\t    Hyphen: 189,\n\t    Dot: 190,\n\t    Slash: 191,\n\t    Backquote: 192,\n\t    LeftBracket: 219,\n\t    Backslash: 220,\n\t    RightBracket: 221,\n\t    Quote: 222,\n\t    Command: 224\n\t};\n\t\n\t(function (factory) {\n\t    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t        // Node/CommonJS\n\t        module.exports = factory(require('jquery'));\n\t    } else {\n\t        // Browser globals\n\t        factory(window.jQuery);\n\t    }\n\t})(function ($) {\n\t    // Helper functions\n\t\n\t    /**\n\t     * Return TRUE if the `value` is null\n\t     *\n\t     * @static\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isNull(value) {\n\t        return value === null;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `value` is undefined\n\t     *\n\t     * @static\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isUndefined(value) {\n\t        return value === void 0;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `value` is undefined, null or empty\n\t     *\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isUndefinedOrNullOrEmpty(value) {\n\t        return value === null || value === void 0 || '' === value;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given parameter is a String\n\t     *\n\t     * @param {*} str\n\t     * @returns {boolean}\n\t     */\n\t    function isString(str) {\n\t        return typeof str === 'string' || str instanceof String;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a boolean\n\t     *\n\t     * @static\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isBoolean(value) {\n\t        return typeof value === 'boolean';\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a string 'true' or 'false'\n\t     *\n\t     * This function accepts any cases for those strings.\n\t     * @param value\n\t     * @returns {boolean}\n\t     */\n\t    function isTrueOrFalseString(value) {\n\t        var lowercaseValue = String(value).toLowerCase();\n\t        return lowercaseValue === 'true' || lowercaseValue === 'false';\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is an object\n\t     *\n\t     * @param {*} reference\n\t     * @returns {boolean}\n\t     */\n\t    function isObject(reference) {\n\t        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given object is empty\n\t     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n\t     *\n\t     * @param obj\n\t     * @returns {boolean}\n\t     */\n\t    function isEmptyObj(obj) {\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the text given as a parameter is valid.\n\t     *\n\t     * @param text\n\t     * @returns {boolean}\n\t     */\n\t    function isValidPasteText(text) {\n\t        return text !== '' && !isNaN(text);\n\t    }\n\t\n\t    /**\n\t     * Return the pasted text that will be used.\n\t     *\n\t     * @param text\n\t     * @param holder\n\t     * @returns {string|void|XML|*}\n\t     */\n\t    function preparePastedText(text, holder) {\n\t        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n\t    }\n\t\n\t    /**\n\t     * Return TRUE is the string `str` contains the string `needle`\n\t     * Note: this function does not coerce the parameters types\n\t     *\n\t     * @param {string} str\n\t     * @param {string} needle\n\t     * @returns {boolean}\n\t     */\n\t    function contains(str, needle) {\n\t        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n\t            return false;\n\t        }\n\t\n\t        return str.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `needle` is in the array\n\t     *\n\t     * @param {Array} array\n\t     * @param {*} needle\n\t     * @returns {boolean}\n\t     */\n\t    function isInArray(needle, array) {\n\t        if (!isArray(array) || array === [] || isUndefined(needle)) {\n\t            return false;\n\t        }\n\t\n\t        return array.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is an Array\n\t     *\n\t     * @param {*} arr\n\t     * @throws Error\n\t     * @returns {*|boolean}\n\t     */\n\t    function isArray(arr) {\n\t        if (Object.prototype.toString.call([]) === '[object Array]') {\n\t            // Make sure an array has a class attribute of [object Array]\n\t            // Test passed, now check if is an Array\n\t            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n\t        } else {\n\t            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n\t     *\n\t     * @param {string} str\n\t     * @returns {boolean}\n\t     */\n\t    function hasDecimals(str) {\n\t        var _str$split = str.split('.'),\n\t            _str$split2 = _slicedToArray(_str$split, 2),\n\t            decimalPart = _str$split2[1];\n\t\n\t        return !isUndefined(decimalPart);\n\t    }\n\t\n\t    /**\n\t     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n\t     * Return `null` otherwise.\n\t     *\n\t     * @param {string} str\n\t     * @returns {null|int}\n\t     */\n\t    function decimalPlaces(str) {\n\t        var _str$split3 = str.split('.'),\n\t            _str$split4 = _slicedToArray(_str$split3, 2),\n\t            decimalPart = _str$split4[1];\n\t\n\t        if (!isUndefined(decimalPart)) {\n\t            return decimalPart.length;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Cross browser routine for getting selected range/cursor position\n\t     */\n\t    function getElementSelection(that) {\n\t        var position = {};\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var select = document.selection.createRange();\n\t            position.length = select.text.length;\n\t            select.moveStart('character', -that.value.length);\n\t            position.end = select.text.length;\n\t            position.start = position.end - position.length;\n\t        } else {\n\t            position.start = that.selectionStart;\n\t            position.end = that.selectionEnd;\n\t            position.length = position.end - position.start;\n\t        }\n\t\n\t        return position;\n\t    }\n\t\n\t    /**\n\t     * Cross browser routine for setting selected range/cursor position\n\t     */\n\t    function setElementSelection(that, start, end) {\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var range = that.createTextRange();\n\t            range.collapse(true);\n\t            range.moveEnd('character', end);\n\t            range.moveStart('character', start);\n\t            range.select();\n\t        } else {\n\t            that.selectionStart = start;\n\t            that.selectionEnd = end;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Function that throw error messages\n\t     *\n\t     * @param {string} message\n\t     */\n\t    function throwError(message) {\n\t        throw new Error(message);\n\t    }\n\t\n\t    /**\n\t     * Function that display a warning messages, according to the debug level.\n\t     *\n\t     * @param {string} message\n\t     * @param {boolean} suppressWarnings If TRUE, then the warning message is not displayed\n\t     */\n\t    function warning(message) {\n\t        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (suppressWarnings) {\n\t            /* eslint no-console: 0 */\n\t            console.warn('Warning: ' + message);\n\t        }\n\t    }\n\t\n\t    // autoNumeric-specific functions\n\t\n\t    /**\n\t     * run callbacks in parameters if any\n\t     * any parameter could be a callback:\n\t     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n\t     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n\t     */\n\t    function runCallbacks($this, settings) {\n\t        // loops through the settings object (option array) to find the following\n\t        $.each(settings, function (k, val) {\n\t            if (typeof val === 'function') {\n\t                settings[k] = val($this, settings, k);\n\t            } else if (typeof $this.autoNumeric[val] === 'function') {\n\t                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n\t                settings[k] = $this.autoNumeric[val]($this, settings, k);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Determine the decimal length from the vMin vMax settings\n\t     */\n\t    function decLength(vMin, vMax) {\n\t        var vMaxLength = 0;\n\t        var vMinLength = 0;\n\t        if (vMax[1]) {\n\t            vMaxLength = vMax[1].length;\n\t        }\n\t        if (vMin[1]) {\n\t            vMinLength = vMin[1].length;\n\t        }\n\t\n\t        return Math.max(vMaxLength, vMinLength);\n\t    }\n\t\n\t    /**\n\t     * Preparing user defined options for further usage\n\t     * merge them with defaults appropriately\n\t     */\n\t    function autoCode($this, settings) {\n\t        //TODO Merge `autoCode()` into `getInitialSettings()`\n\t        runCallbacks($this, settings);\n\t        var vMax = settings.vMax.toString().split('.');\n\t        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n\t        vMax[0] = vMax[0].replace('-', '');\n\t        vMin[0] = vMin[0].replace('-', '');\n\t        settings.mIntPos = Math.max(vMax[0].length, 1);\n\t        settings.mIntNeg = Math.max(vMin[0].length, 1);\n\t        if (settings.mDec === null) {\n\t            settings.mDec = decLength(vMin, vMax);\n\t            settings.oDec = settings.mDec;\n\t        } else {\n\t            settings.mDec = Number(settings.mDec);\n\t        }\n\t\n\t        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\t\n\t        // set alternative decimal separator key\n\t        if (settings.altDec === null && settings.mDec > 0) {\n\t            if (settings.aDec === '.' && settings.aSep !== ',') {\n\t                settings.altDec = ',';\n\t            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n\t                settings.altDec = '.';\n\t            }\n\t        }\n\t\n\t        // cache regexps for autoStrip\n\t        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n\t        settings.aNegRegAutoStrip = aNegReg;\n\t        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n\t        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n\t        var allowed = '-0123456789\\\\' + settings.aDec;\n\t        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\t\n\t        return settings;\n\t    }\n\t\n\t    /**\n\t     * strip all unwanted characters and leave only a number alert\n\t     */\n\t    function autoStrip(s, settings) {\n\t        if (settings.aSign !== '') {\n\t            // remove currency sign\n\t            s = s.replace(settings.aSign, '');\n\t        }\n\t        if (settings.aSuffix) {\n\t            // remove suffix\n\t            while (contains(s, settings.aSuffix)) {\n\t                s = s.replace(settings.aSuffix, '');\n\t            }\n\t        }\n\t\n\t        // first replace anything before digits\n\t        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\t\n\t        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n\t            settings.trailingNegative = true;\n\t        }\n\t\n\t        // then replace anything after digits\n\t        s = s.replace(settings.skipLastAutoStrip, '$1');\n\t\n\t        // then remove any uninterested characters\n\t        s = s.replace(settings.allowedAutoStrip, '');\n\t        if (settings.altDec) {\n\t            s = s.replace(settings.altDec, settings.aDec);\n\t        }\n\t\n\t        // get only number string\n\t        var m = s.match(settings.numRegAutoStrip);\n\t        s = m ? [m[1], m[2], m[3]].join('') : '';\n\t        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n\t            var nSign = '';\n\t\n\t            var _s$split = s.split(settings.aDec),\n\t                _s$split2 = _slicedToArray(_s$split, 2),\n\t                integerPart = _s$split2[0],\n\t                decimalPart = _s$split2[1];\n\t\n\t            var modifiedIntegerPart = integerPart;\n\t            if (contains(modifiedIntegerPart, settings.aNeg)) {\n\t                nSign = settings.aNeg;\n\t                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n\t            }\n\t\n\t            // strip leading zero on positive value if need\n\t            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            // strip leading zero on negative value if need\n\t            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n\t        }\n\t        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n\t            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n\t            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n\t            stripReg = new RegExp(stripReg);\n\t            s = s.replace(stripReg, '$1$2');\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Places or removes brackets on negative values\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function negativeBracket(s, settings) {\n\t        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n\t            var _settings$nBracket$sp = settings.nBracket.split(','),\n\t                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n\t                firstBracket = _settings$nBracket$sp2[0],\n\t                lastBracket = _settings$nBracket$sp2[1];\n\t\n\t            if (!settings.onOff) {\n\t                s = s.replace(settings.aNeg, '');\n\t                s = firstBracket + s + lastBracket;\n\t            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n\t                s = s.replace(firstBracket, settings.aNeg);\n\t                s = s.replace(lastBracket, '');\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * convert locale format to Javascript numeric string\n\t     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n\t     * '1234.56'    OK\n\t     * '-1234.56'   OK\n\t     * '1234.56-'   OK\n\t     * '1234,56'    OK\n\t     * '-1234,56'   OK\n\t     * '1234,56-'   OK\n\t     */\n\t    function fromLocale(s) {\n\t        s = s.replace(',', '.');\n\t        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n\t            s = s.replace('-', '');\n\t            s = '-' + s;\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n\t     * See the \"outputType\" option definition for more details.\n\t     */\n\t    function toLocale(value, locale) {\n\t        if (isNull(locale) || locale === 'string') {\n\t            return value;\n\t        }\n\t\n\t        var result = void 0;\n\t        switch (locale) {\n\t            case 'number':\n\t                result = Number(value);\n\t                break;\n\t            case '.-':\n\t                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n\t                break;\n\t            case ',':\n\t            case '-,':\n\t                result = value.replace('.', ',');\n\t                break;\n\t            case ',-':\n\t                result = value.replace('.', ',');\n\t                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n\t                break;\n\t            // The default case\n\t            case '.':\n\t            case '-.':\n\t                result = value;\n\t                break;\n\t            default:\n\t                throwError('The given outputType [' + locale + '] option is not recognized.');\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Prepare number string to be converted to real number\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function fixNumber(s, settings) {\n\t        if (settings.aDec !== '.') {\n\t            s = s.replace(settings.aDec, '.');\n\t        }\n\t        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n\t            s = s.replace(settings.aNeg, '-');\n\t        }\n\t        if (!s.match(/\\d/)) {\n\t            // The default value returned by `get` is formatted with decimals\n\t            s += '0.00';\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Prepare real number to be converted to our format\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function presentNumber(s, settings) {\n\t        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n\t            s = s.replace('-', settings.aNeg);\n\t        }\n\t        if (settings.aDec !== '.') {\n\t            s = s.replace('.', settings.aDec);\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Private function to check for empty value\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @param {boolean} signOnEmpty\n\t     * @returns {*}\n\t     */\n\t    function checkEmpty(inputValue, settings, signOnEmpty) {\n\t        if (inputValue === '' || inputValue === settings.aNeg) {\n\t            if (settings.wEmpty === 'always' || signOnEmpty) {\n\t                return settings.pNeg === 'l' ? inputValue + settings.aSign + settings.aSuffix : settings.aSign + inputValue + settings.aSuffix;\n\t            }\n\t\n\t            return inputValue;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Private function that formats our number\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function autoGroup(inputValue, settings) {\n\t        if (settings.strip) {\n\t            inputValue = autoStrip(inputValue, settings);\n\t        }\n\t\n\t        if (settings.trailingNegative && !contains(inputValue, '-')) {\n\t            inputValue = '-' + inputValue;\n\t        }\n\t\n\t        var empty = checkEmpty(inputValue, settings, true);\n\t        var isNeg = contains(inputValue, '-');\n\t        if (isNeg) {\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        if (empty !== null) {\n\t            return empty;\n\t        }\n\t\n\t        var digitalGroup = '';\n\t        settings.dGroup = settings.dGroup.toString();\n\t        if (settings.dGroup === '2') {\n\t            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n\t        } else if (settings.dGroup === '2s') {\n\t            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n\t        } else if (settings.dGroup === '4') {\n\t            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n\t        } else {\n\t            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n\t        }\n\t\n\t        // splits the string at the decimal string\n\t\n\t        var _inputValue$split = inputValue.split(settings.aDec),\n\t            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n\t            integerPart = _inputValue$split2[0],\n\t            decimalPart = _inputValue$split2[1];\n\t\n\t        if (settings.altDec && isUndefined(decimalPart)) {\n\t            var _inputValue$split3 = inputValue.split(settings.altDec);\n\t\n\t            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\t\n\t            integerPart = _inputValue$split4[0];\n\t            decimalPart = _inputValue$split4[1];\n\t        }\n\t\n\t        if (settings.aSep !== '') {\n\t            // re-inserts the thousand separator via a regular expression\n\t            while (digitalGroup.test(integerPart)) {\n\t                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n\t            }\n\t        }\n\t\n\t        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n\t            if (decimalPart.length > settings.mDec) {\n\t                decimalPart = decimalPart.substring(0, settings.mDec);\n\t            }\n\t\n\t            // joins the whole number with the decimal value\n\t            inputValue = integerPart + settings.aDec + decimalPart;\n\t        } else {\n\t            // if whole numbers only\n\t            inputValue = integerPart;\n\t        }\n\t\n\t        if (settings.pSign === 'p') {\n\t            if (isNeg && settings.pNeg === 'l') {\n\t                inputValue = settings.aNeg + settings.aSign + inputValue;\n\t            }\n\t            if (isNeg && settings.pNeg === 'r') {\n\t                inputValue = settings.aSign + settings.aNeg + inputValue;\n\t            }\n\t            if (isNeg && settings.pNeg === 's') {\n\t                inputValue = settings.aSign + inputValue + settings.aNeg;\n\t            }\n\t            if (!isNeg) {\n\t                inputValue = settings.aSign + inputValue;\n\t            }\n\t        }\n\t\n\t        if (settings.pSign === 's') {\n\t            if (isNeg && settings.pNeg === 'r') {\n\t                inputValue = inputValue + settings.aSign + settings.aNeg;\n\t            }\n\t            if (isNeg && settings.pNeg === 'l') {\n\t                inputValue = inputValue + settings.aNeg + settings.aSign;\n\t            }\n\t            if (isNeg && settings.pNeg === 'p') {\n\t                inputValue = settings.aNeg + inputValue + settings.aSign;\n\t            }\n\t            if (!isNeg) {\n\t                inputValue = inputValue + settings.aSign;\n\t            }\n\t        }\n\t\n\t        // removes the negative sign and places brackets\n\t        if (settings.nBracket !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n\t            inputValue = negativeBracket(inputValue, settings);\n\t        }\n\t        settings.trailingNegative = false;\n\t\n\t        return inputValue + settings.aSuffix;\n\t    }\n\t\n\t    /**\n\t     * Truncate not needed zeros\n\t     *\n\t     * @param {string} roundedInputValue\n\t     * @param rDec\n\t     * @returns {void|XML|string|*}\n\t     */\n\t    function truncateZeros(roundedInputValue, rDec) {\n\t        var regex = void 0;\n\t        switch (rDec) {\n\t            case 0:\n\t                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n\t                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            case 1:\n\t                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n\t                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            default:\n\t                // Removes access zeros to the mDec length when aPad is set to true\n\t                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n\t        }\n\t\n\t        // If there are no decimal places, we don't need a decimal point at the end\n\t        roundedInputValue = roundedInputValue.replace(regex, '$1');\n\t        if (rDec === 0) {\n\t            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n\t        }\n\t\n\t        return roundedInputValue;\n\t    }\n\t\n\t    /**\n\t     * round number after setting by pasting or $().autoNumericSet()\n\t     * private function for round the number\n\t     * please note this handled as text - JavaScript math function can return inaccurate values\n\t     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function autoRound(inputValue, settings) {\n\t        // value to string\n\t        inputValue = inputValue === '' ? '0' : inputValue.toString();\n\t        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n\t            switch (settings.mRound) {\n\t                case 'N05':\n\t                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n\t                    break;\n\t                case 'U05':\n\t                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n\t                    break;\n\t                default:\n\t                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n\t            }\n\t\n\t            var result = void 0;\n\t            if (!contains(inputValue, '.')) {\n\t                result = inputValue + '.00';\n\t            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n\t                result = inputValue + '0';\n\t            } else {\n\t                result = inputValue;\n\t            }\n\t            return result;\n\t        }\n\t\n\t        var ivRounded = '';\n\t        var i = 0;\n\t        var nSign = '';\n\t        var rDec = void 0;\n\t\n\t        // sets the truncate zero method\n\t        if (settings.aPad) {\n\t            rDec = settings.mDec;\n\t        } else {\n\t            rDec = 0;\n\t        }\n\t\n\t        // Checks if the inputValue (input Value) is a negative value\n\t        if (inputValue.charAt(0) === '-') {\n\t            nSign = '-';\n\t\n\t            // Removes the negative sign that will be added back later if required\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n\t        if (!inputValue.match(/^\\d/)) {\n\t            inputValue = '0' + inputValue;\n\t        }\n\t\n\t        // Determines if the value is equal to zero. If it is, remove the negative sign\n\t        if (nSign === '-' && Number(inputValue) === 0) {\n\t            nSign = '';\n\t        }\n\t\n\t        // Trims leading zero's as needed\n\t        if (Number(inputValue) > 0 && settings.lZero !== 'keep' || inputValue.length > 0 && settings.lZero === 'allow') {\n\t            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n\t        }\n\t\n\t        var dPos = inputValue.lastIndexOf('.');\n\t\n\t        // Virtual decimal position\n\t        var vdPos = dPos === -1 ? inputValue.length - 1 : dPos;\n\t\n\t        // Checks decimal places to determine if rounding is required :\n\t        // Check if no rounding is required\n\t        var cDec = inputValue.length - 1 - vdPos;\n\t\n\t        if (cDec <= settings.mDec) {\n\t            // Check if we need to pad with zeros\n\t            ivRounded = inputValue;\n\t            if (cDec < rDec) {\n\t                if (dPos === -1) {\n\t                    ivRounded += settings.aDec;\n\t                }\n\t\n\t                var zeros = '000000';\n\t                while (cDec < rDec) {\n\t                    zeros = zeros.substring(0, rDec - cDec);\n\t                    ivRounded += zeros;\n\t                    cDec += zeros.length;\n\t                }\n\t            } else if (cDec > rDec) {\n\t                ivRounded = truncateZeros(ivRounded, rDec);\n\t            } else if (cDec === 0 && rDec === 0) {\n\t                ivRounded = ivRounded.replace(/\\.$/, '');\n\t            }\n\t\n\t            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t        }\n\t\n\t        // Rounded length of the string after rounding\n\t        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n\t        var tRound = Number(inputValue.charAt(rLength + 1));\n\t        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n\t        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\t\n\t        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n\t        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n\t        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n\t        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n\t        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n\t        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n\t        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n\t        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n\t        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n\t        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n\t        tRound > 0 && settings.mRound === 'U') {\n\t            // Round up away from zero\n\t            // Round up the last digit if required, and continue until no more 9's are found\n\t            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n\t                if (ivArray[i] !== '.') {\n\t                    ivArray[i] = +ivArray[i] + 1;\n\t                    if (ivArray[i] < 10) {\n\t                        break;\n\t                    }\n\t\n\t                    if (i > 0) {\n\t                        ivArray[i] = '0';\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Reconstruct the string, converting any 10's to 0's\n\t        ivArray = ivArray.slice(0, rLength + 1);\n\t\n\t        // Return the rounded value\n\t        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\t\n\t        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t    }\n\t\n\t    /**\n\t     * Truncates the decimal part of a number\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @param {string} paste\n\t     * @returns {*}\n\t     */\n\t    function truncateDecimal(s, settings, paste) {\n\t        var aDec = settings.aDec;\n\t        var mDec = settings.mDec;\n\t        s = paste === 'paste' ? autoRound(s, settings) : s;\n\t\n\t        if (aDec && mDec) {\n\t            var _s$split3 = s.split(aDec),\n\t                _s$split4 = _slicedToArray(_s$split3, 2),\n\t                integerPart = _s$split4[0],\n\t                decimalPart = _s$split4[1];\n\t\n\t            // truncate decimal part to satisfying length since we would round it anyway\n\t\n\t\n\t            if (decimalPart && decimalPart.length > mDec) {\n\t                if (mDec > 0) {\n\t                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n\t                    s = '' + integerPart + aDec + modifiedDecimalPart;\n\t                } else {\n\t                    s = integerPart;\n\t                }\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n\t     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n\t     * Many thanks to Mike\n\t     */\n\t    function parseStr(n) {\n\t        var x = {};\n\t        var e = void 0;\n\t        var i = void 0;\n\t        var nL = void 0;\n\t        var j = void 0;\n\t\n\t        // Minus zero?\n\t        if (n === 0 && 1 / n < 0) {\n\t            n = '-0';\n\t        }\n\t\n\t        // Determine sign. 1 positive, -1 negative\n\t        n = n.toString();\n\t        if (n.charAt(0) === '-') {\n\t            n = n.slice(1);\n\t            x.s = -1;\n\t        } else {\n\t            x.s = 1;\n\t        }\n\t\n\t        // Decimal point?\n\t        e = n.indexOf('.');\n\t        if (e > -1) {\n\t            n = n.replace('.', '');\n\t        }\n\t\n\t        // length of string if no decimal character\n\t        if (e < 0) {\n\t            // Integer\n\t            e = n.length;\n\t        }\n\t\n\t        // Determine leading zeros\n\t        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n\t        nL = n.length;\n\t        if (i === nL) {\n\t            // Zero\n\t            x.e = 0;\n\t            x.c = [0];\n\t        } else {\n\t            // Determine trailing zeros\n\t            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n\t                nL -= 1;\n\t            }\n\t            nL -= 1;\n\t\n\t            // Decimal location\n\t            x.e = e - i - 1;\n\t            x.c = [];\n\t\n\t            // Convert string to array of digits without leading/trailing zeros\n\t            for (e = 0; i <= nL; i += 1) {\n\t                x.c[e] = +n.charAt(i);\n\t                e += 1;\n\t            }\n\t        }\n\t\n\t        return x;\n\t    }\n\t\n\t    /**\n\t     * Function to test if the input value falls with the Min / Max settings\n\t     * This uses the parsed strings for the above parseStr function\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n\t     * Many thanks to Mike\n\t     */\n\t    function testMinMax(y, x) {\n\t        var xc = x.c;\n\t        var yc = y.c;\n\t        var i = x.s;\n\t        var j = y.s;\n\t        var k = x.e;\n\t        var l = y.e;\n\t\n\t        // Either zero?\n\t        if (!xc[0] || !yc[0]) {\n\t            var _result = void 0;\n\t            if (!xc[0]) {\n\t                _result = !yc[0] ? 0 : -j;\n\t            } else {\n\t                _result = i;\n\t            }\n\t            return _result;\n\t        }\n\t\n\t        // Signs differ?\n\t        if (i !== j) {\n\t            return i;\n\t        }\n\t        var xNeg = i < 0;\n\t\n\t        // Compare exponents\n\t        if (k !== l) {\n\t            return k > l ^ xNeg ? 1 : -1;\n\t        }\n\t        i = -1;\n\t        k = xc.length;\n\t        l = yc.length;\n\t        j = k < l ? k : l;\n\t\n\t        // Compare digit by digit\n\t        for (i += 1; i < j; i += 1) {\n\t            if (xc[i] !== yc[i]) {\n\t                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n\t            }\n\t        }\n\t\n\t        // Compare lengths\n\t        var result = void 0;\n\t        if (k === l) {\n\t            result = 0;\n\t        } else {\n\t            result = k > l ^ xNeg ? 1 : -1;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Check that the number satisfy the format conditions\n\t     * and lays between settings.vMin and settings.vMax\n\t     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function autoCheck(s, settings) {\n\t        s = s.toString();\n\t        s = s.replace(',', '.');\n\t        var minParse = parseStr(settings.vMin);\n\t        var maxParse = parseStr(settings.vMax);\n\t        var valParse = parseStr(s);\n\t\n\t        var result = void 0;\n\t        switch (settings.oLimits) {\n\t            case 'floor':\n\t                result = [testMinMax(minParse, valParse) > -1, true];\n\t                break;\n\t            case 'ceiling':\n\t                result = [true, testMinMax(maxParse, valParse) < 1];\n\t                break;\n\t            case 'ignore':\n\t                result = [true, true];\n\t                break;\n\t            default:\n\t                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * thanks to Anthony & Evan C\n\t     */\n\t    function autoGet(obj) {\n\t        /*\n\t         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n\t         * for jQuery to be able to parse the selector correctly.\n\t         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n\t         */\n\t        if (isString(obj)) {\n\t            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n\t            obj = '#' + obj.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n\t        }\n\t\n\t        return $(obj);\n\t    }\n\t\n\t    /**\n\t     * Function to attach data to the element and imitate the holder\n\t     *\n\t     * @param $that\n\t     * @param {object} settings\n\t     * @param {boolean} update\n\t     * @returns {*}\n\t     */\n\t    function getHolder($that, settings) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        var data = $that.data('autoNumeric');\n\t        if (!data) {\n\t            data = {};\n\t            $that.data('autoNumeric', data);\n\t        }\n\t\n\t        var holder = data.holder;\n\t        if (isUndefined(holder) && settings || update) {\n\t            holder = new AutoNumericHolder($that.get(0), settings);\n\t            data.holder = holder;\n\t        }\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Original settings saved for use when eDec & nSep options are being used.\n\t     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function keepOriginalSettings(settings) {\n\t        settings.oDec = settings.mDec;\n\t        settings.oPad = settings.aPad;\n\t        settings.oBracket = settings.nBracket;\n\t        settings.oSep = settings.aSep;\n\t        settings.oSign = settings.aSign;\n\t        settings.oSuffix = settings.aSuffix;\n\t    }\n\t\n\t    /**\n\t     * original settings saved for use when eDec & nSep options are being used\n\t     * taken from Quirksmode\n\t     */\n\t    function readCookie(name) {\n\t        var nameEQ = name + '=';\n\t        var ca = document.cookie.split(';');\n\t        var c = '';\n\t        for (var i = 0; i < ca.length; i += 1) {\n\t            c = ca[i];\n\t            while (c.charAt(0) === ' ') {\n\t                c = c.substring(1, c.length);\n\t            }\n\t            if (c.indexOf(nameEQ) === 0) {\n\t                return c.substring(nameEQ.length, c.length);\n\t            }\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Test if sessionStorage is supported - taken from modernizr\n\t     */\n\t    function storageTest() {\n\t        var mod = 'modernizr';\n\t        try {\n\t            sessionStorage.setItem(mod, mod);\n\t            sessionStorage.removeItem(mod);\n\t            return true;\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * creates or removes sessionStorage or cookie depending on browser support\n\t     */\n\t    function autoSave($this, settings, toDo) {\n\t        if (settings.aStor) {\n\t            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n\t            var date = void 0;\n\t            var expires = void 0;\n\t\n\t            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n\t            if (storageTest() === false) {\n\t                switch (toDo) {\n\t                    case 'set':\n\t                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n\t                        break;\n\t                    case 'wipe':\n\t                        date = new Date();\n\t                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n\t                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n\t                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n\t                        break;\n\t                    case 'get':\n\t                        return readCookie(storedName);\n\t                }\n\t            } else {\n\t                switch (toDo) {\n\t                    case 'set':\n\t                        sessionStorage.setItem(storedName, settings.rawValue);\n\t                        break;\n\t                    case 'wipe':\n\t                        sessionStorage.removeItem(storedName);\n\t                        break;\n\t                    case 'get':\n\t                        return sessionStorage.getItem(storedName);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Holder object for field properties\n\t     *\n\t     * @param that\n\t     * @param {object} settings\n\t     * @constructor\n\t     */\n\t    function AutoNumericHolder(that, settings) {\n\t        this.settings = settings;\n\t        this.that = that;\n\t        this.$that = $(that);\n\t        this.formatted = false;\n\t        this.settingsClone = autoCode(this.$that, this.settings);\n\t        this.value = that.value;\n\t    }\n\t\n\t    AutoNumericHolder.prototype = {\n\t        init: function init(e) {\n\t            this.value = this.that.value;\n\t            this.settingsClone = autoCode(this.$that, this.settings);\n\t            this.ctrlKey = e.ctrlKey;\n\t            this.cmdKey = e.metaKey;\n\t            this.shiftKey = e.shiftKey;\n\t\n\t            // keypress event overwrites meaningful value of e.keyCode\n\t            this.selection = getElementSelection(this.that);\n\t            if (e.type === 'keydown' || e.type === 'keyup') {\n\t                this.kdCode = e.keyCode;\n\t            }\n\t            this.which = e.which;\n\t            this.processed = false;\n\t            this.formatted = false;\n\t        },\n\t        setSelection: function setSelection(start, end, setReal) {\n\t            start = Math.max(start, 0);\n\t            end = Math.min(end, this.that.value.length);\n\t            this.selection = {\n\t                start: start,\n\t                end: end,\n\t                length: end - start\n\t            };\n\t            if (isUndefined(setReal) || setReal) {\n\t                setElementSelection(this.that, start, end);\n\t            }\n\t        },\n\t        setPosition: function setPosition(pos, setReal) {\n\t            this.setSelection(pos, pos, setReal);\n\t        },\n\t        getBeforeAfter: function getBeforeAfter() {\n\t            var value = this.value;\n\t            var left = value.substring(0, this.selection.start);\n\t            var right = value.substring(this.selection.end, value.length);\n\t\n\t            return [left, right];\n\t        },\n\t        getBeforeAfterStriped: function getBeforeAfterStriped() {\n\t            var settingsClone = this.settingsClone;\n\t\n\t            var _getBeforeAfter = this.getBeforeAfter(),\n\t                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n\t                left = _getBeforeAfter2[0],\n\t                right = _getBeforeAfter2[1];\n\t\n\t            left = autoStrip(left, this.settingsClone);\n\t            right = autoStrip(right, this.settingsClone);\n\t            if (settingsClone.trailingNegative && !contains(left, '-')) {\n\t                left = '-' + left;\n\t                right = right === '-' ? '' : right;\n\t            }\n\t            settingsClone.trailingNegative = false;\n\t\n\t            return [left, right];\n\t        },\n\t\n\t\n\t        /**\n\t         * strip parts from excess characters and leading zeroes\n\t         */\n\t        normalizeParts: function normalizeParts(left, right) {\n\t            var settingsClone = this.settingsClone;\n\t\n\t            // prevents multiple leading zeros from being entered\n\t            left = autoStrip(left, settingsClone);\n\t\n\t            // if right is not empty and first character is not aDec,\n\t            right = autoStrip(right, settingsClone);\n\t            if (settingsClone.trailingNegative && !contains(left, '-')) {\n\t                left = '-' + left;\n\t                settingsClone.trailingNegative = false;\n\t            }\n\t            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n\t                if (right > '') {\n\t                    right = right.replace(/^0*(\\d)/, '$1');\n\t                }\n\t            }\n\t\n\t            // insert zero if has leading dot\n\t            this.newValue = left + right;\n\t            if (settingsClone.aDec) {\n\t                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n\t                if (m) {\n\t                    left = left.replace(m[1], m[1] + '0');\n\t                    this.newValue = left + right;\n\t                }\n\t            }\n\t\n\t            return [left, right];\n\t        },\n\t\n\t\n\t        /**\n\t         * set part of number to value keeping position of cursor\n\t         */\n\t        setValueParts: function setValueParts(left, right, advent) {\n\t            var settingsClone = this.settingsClone;\n\t            var parts = this.normalizeParts(left, right);\n\t\n\t            var _autoCheck = autoCheck(this.newValue, settingsClone),\n\t                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n\t                minTest = _autoCheck2[0],\n\t                maxTest = _autoCheck2[1];\n\t\n\t            var position = parts[0].length;\n\t            this.newValue = parts.join('');\n\t\n\t            if (minTest && maxTest) {\n\t                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n\t                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n\t                if (testValue === '' || testValue === settingsClone.aNeg) {\n\t                    settingsClone.rawValue = '';\n\t                } else {\n\t                    settingsClone.rawValue = testValue;\n\t                }\n\t                if (position > this.newValue.length) {\n\t                    position = this.newValue.length;\n\t                }\n\t                this.value = this.newValue;\n\t                this.setPosition(position, false);\n\t                return true;\n\t            }\n\t\n\t            if (!minTest) {\n\t                this.$that.trigger('autoNumeric:minExceeded');\n\t            } else if (!maxTest) {\n\t                this.$that.trigger('autoNumeric:maxExceeded');\n\t            }\n\t\n\t            return false;\n\t        },\n\t\n\t\n\t        /**\n\t         * helper function for expandSelectionOnSign\n\t         * returns sign position of a formatted value\n\t         */\n\t        signPosition: function signPosition() {\n\t            var settingsClone = this.settingsClone;\n\t            var aSign = settingsClone.aSign;\n\t            var that = this.that;\n\t\n\t            if (aSign) {\n\t                var aSignLen = aSign.length;\n\t                if (settingsClone.pSign === 'p') {\n\t                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n\t                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n\t                }\n\t                var valueLen = that.value.length;\n\t                return [valueLen - aSignLen, valueLen];\n\t            }\n\t\n\t            return [1000, -1];\n\t        },\n\t\n\t\n\t        /**\n\t         * expands selection to cover whole sign\n\t         * prevents partial deletion/copying/overwriting of a sign\n\t         */\n\t        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n\t            var signPosition = this.signPosition();\n\t            var selection = this.selection;\n\t\n\t            // if selection catches something except sign and catches only space from sign\n\t            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n\t                // then select without empty space\n\t                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n\t                    if (selection.start < signPosition[0]) {\n\t                        this.setSelection(selection.start, signPosition[0], setReal);\n\t                    } else {\n\t                        this.setSelection(signPosition[1], selection.end, setReal);\n\t                    }\n\t                } else {\n\t                    // else select with whole sign\n\t                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n\t                }\n\t            }\n\t        },\n\t\n\t\n\t        /**\n\t         * try to strip pasted value to digits\n\t         */\n\t        checkPaste: function checkPaste() {\n\t            if (!isUndefined(this.valuePartsBeforePaste)) {\n\t                var oldParts = this.valuePartsBeforePaste;\n\t\n\t                var _getBeforeAfter3 = this.getBeforeAfter(),\n\t                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n\t                    left = _getBeforeAfter4[0],\n\t                    right = _getBeforeAfter4[1];\n\t\n\t                // try to strip pasted value first\n\t\n\t\n\t                delete this.valuePartsBeforePaste;\n\t                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n\t                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n\t                    this.value = oldParts.join('');\n\t                    this.setPosition(oldParts[0].length, false);\n\t                }\n\t            }\n\t        },\n\t\n\t\n\t        /**\n\t         * process pasting, cursor moving and skipping of not interesting keys\n\t         * if returns true, further processing is not performed\n\t         */\n\t        skipAlways: function skipAlways(e) {\n\t            var kdCode = this.kdCode;\n\t            var which = this.which;\n\t            var ctrlKey = this.ctrlKey;\n\t            var cmdKey = this.cmdKey;\n\t\n\t            // catch the ctrl up on ctrl-v\n\t            var shiftKey = this.shiftKey;\n\t            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n\t                this.checkPaste();\n\t                return false;\n\t            }\n\t\n\t            // skip Fx keys, windows keys, other special keys\n\t            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n\t                return true;\n\t            }\n\t\n\t            // if select all (a)\n\t            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n\t                if (this.settings.sNumber) {\n\t                    e.preventDefault();\n\t                    var valueLen = this.that.value.length;\n\t                    var aSignLen = this.settings.aSign.length;\n\t                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n\t                    var aSuffixLen = this.settings.aSuffix.length;\n\t                    var pSign = this.settings.pSign;\n\t                    var pNeg = this.settings.pNeg;\n\t\n\t                    var start = void 0;\n\t                    if (pSign === 's') {\n\t                        start = 0;\n\t                    } else {\n\t                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n\t                    }\n\t\n\t                    var end = void 0;\n\t                    if (pSign === 'p') {\n\t                        end = valueLen - aSuffixLen;\n\t                    } else {\n\t                        switch (pNeg) {\n\t                            case 'l':\n\t                                end = valueLen - (aSuffixLen + aSignLen);\n\t                                break;\n\t                            case 'r':\n\t                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n\t                                break;\n\t                            default:\n\t                                end = valueLen - (aSignLen + aSuffixLen);\n\t                        }\n\t                    }\n\t\n\t                    setElementSelection(this.that, start, end);\n\t                }\n\t                return true;\n\t            }\n\t\n\t            // if copy (c)\n\t            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n\t                if (e.type === 'keydown') {\n\t                    this.expandSelectionOnSign();\n\t                }\n\t\n\t                // try to prevent wrong paste\n\t                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n\t                    if (e.type === 'keydown' || e.type === 'keypress') {\n\t                        if (isUndefined(this.valuePartsBeforePaste)) {\n\t                            this.valuePartsBeforePaste = this.getBeforeAfter();\n\t                        }\n\t                    } else {\n\t                        this.checkPaste();\n\t                    }\n\t                }\n\t                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n\t            }\n\t\n\t            if (ctrlKey || cmdKey) {\n\t                return true;\n\t            }\n\t\n\t            // jump over thousand separator\n\t            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n\t                var aSep = this.settingsClone.aSep;\n\t                var aDec = this.settingsClone.aDec;\n\t                var startJump = this.selection.start;\n\t                var value = this.that.value;\n\t                if (e.type === 'keydown' && !this.shiftKey) {\n\t                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n\t                        this.setPosition(startJump - 1);\n\t                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n\t                        this.setPosition(startJump + 1);\n\t                    }\n\t                }\n\t                return true;\n\t            }\n\t\n\t            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n\t        },\n\t\n\t\n\t        /**\n\t         * process deletion of characters when the minus sign is to the right of the numeric characters\n\t         */\n\t        processTrailing: function processTrailing(_ref) {\n\t            var _ref2 = _slicedToArray(_ref, 2),\n\t                left = _ref2[0],\n\t                right = _ref2[1];\n\t\n\t            var settingsClone = this.settingsClone;\n\t            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n\t                if (this.kdCode === 8) {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n\t                    if (this.value.charAt(this.selection.start - 1) === '-') {\n\t                        left = left.substring(1);\n\t                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n\t                        left = left.substring(0, left.length - 1);\n\t                    }\n\t                } else {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n\t                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n\t                        left = left.substring(1);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n\t                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n\t                if (this.kdCode === 8) {\n\t                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n\t                        left = left.substring(1);\n\t                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n\t                        left = left.substring(0, left.length - 1);\n\t                    }\n\t                } else {\n\t                    if (left[0] === '-') {\n\t                        right = right.substring(1);\n\t                    }\n\t                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n\t                        left = left.substring(1);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n\t                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n\t                if (this.kdCode === 8) {\n\t                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n\t                        left = left.substring(1);\n\t                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n\t                        left = left.substring(0, left.length - 1);\n\t                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n\t                        left = left.substring(0, left.length - 1);\n\t                    }\n\t                } else {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '';\n\t                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n\t                        left = left.substring(1);\n\t                    }\n\t                    right = right.substring(1);\n\t                }\n\t            }\n\t\n\t            return [left, right];\n\t        },\n\t\n\t\n\t        /**\n\t         * process deletion of characters\n\t         * returns true if processing performed\n\t         */\n\t        processAlways: function processAlways() {\n\t            var settingsClone = this.settingsClone;\n\t            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n\t                var left = void 0;\n\t                var right = void 0;\n\t\n\t                if (!this.selection.length) {\n\t                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\t\n\t                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\t\n\t                    left = _getBeforeAfterStripe2[0];\n\t                    right = _getBeforeAfterStripe2[1];\n\t\n\t                    if (left === '' && right === '') {\n\t                        settingsClone.throwInput = false;\n\t                    }\n\t\n\t                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n\t                        var _processTrailing = this.processTrailing([left, right]);\n\t\n\t                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\t\n\t                        left = _processTrailing2[0];\n\t                        right = _processTrailing2[1];\n\t                    } else {\n\t                        if (this.kdCode === 8) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                    }\n\t                    this.setValueParts(left, right);\n\t                } else {\n\t                    this.expandSelectionOnSign(false);\n\t\n\t                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\t\n\t                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\t\n\t                    left = _getBeforeAfterStripe4[0];\n\t                    right = _getBeforeAfterStripe4[1];\n\t\n\t                    this.setValueParts(left, right);\n\t                }\n\t\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        },\n\t\n\t\n\t        /**\n\t         * process insertion of characters\n\t         * returns true if processing performed\n\t         */\n\t        processKeypress: function processKeypress() {\n\t            var settingsClone = this.settingsClone;\n\t            var cCode = String.fromCharCode(this.which);\n\t\n\t            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n\t                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n\t                left = _getBeforeAfterStripe6[0],\n\t                right = _getBeforeAfterStripe6[1];\n\t\n\t            settingsClone.throwInput = true;\n\t\n\t            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n\t            // do not allow decimal character if no decimal part allowed\n\t            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n\t                if (!settingsClone.mDec || !settingsClone.aDec) {\n\t                    return true;\n\t                }\n\t\n\t                // do not allow decimal character before aNeg character\n\t                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n\t                    return true;\n\t                }\n\t\n\t                // do not allow decimal character if other decimal character present\n\t                if (contains(left, settingsClone.aDec)) {\n\t                    return true;\n\t                }\n\t                if (right.indexOf(settingsClone.aDec) > 0) {\n\t                    return true;\n\t                }\n\t                if (right.indexOf(settingsClone.aDec) === 0) {\n\t                    right = right.substr(1);\n\t                }\n\t                this.setValueParts(left + settingsClone.aDec, right, null);\n\t\n\t                return true;\n\t            }\n\t\n\t            // prevent minus if not allowed\n\t            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n\t                if (!settingsClone) {\n\t                    return true;\n\t                }\n\t\n\t                // caret is always after minus\n\t                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n\t                    if (left === '' && contains(right, settingsClone.aNeg)) {\n\t                        left = settingsClone.aNeg;\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t\n\t                    // change sign of number, remove part if should\n\t                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n\t                        left = left.substring(1, left.length);\n\t                    } else {\n\t                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n\t                    }\n\t                } else {\n\t                    if (left === '' && contains(right, settingsClone.aNeg)) {\n\t                        left = settingsClone.aNeg;\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t\n\t                    // change sign of number, remove part if should\n\t                    if (left.charAt(0) === settingsClone.aNeg) {\n\t                        left = left.substring(1, left.length);\n\t                    } else {\n\t                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n\t                    }\n\t                }\n\t                this.setValueParts(left, right, null);\n\t\n\t                return true;\n\t            }\n\t\n\t            // if try to insert digit before minus\n\t            if (cCode >= '0' && cCode <= '9') {\n\t                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n\t                    left = settingsClone.aNeg;\n\t                    right = right.substring(1, right.length);\n\t                }\n\t                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n\t                    left = settingsClone.aNeg + left;\n\t                }\n\t                this.setValueParts(left + cCode, right, null);\n\t                return true;\n\t            }\n\t\n\t            // prevent any other character\n\t            settingsClone.throwInput = false;\n\t\n\t            return true;\n\t        },\n\t\n\t\n\t        /**\n\t         * formatting of just processed value with keeping of cursor position\n\t         */\n\t        formatQuick: function formatQuick(e) {\n\t            var _this = this;\n\t\n\t            var settingsClone = this.settingsClone;\n\t            var leftLength = this.value;\n\t            var kuCode = e.keyCode;\n\t\n\t            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n\t                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n\t                left = _getBeforeAfterStripe8[0];\n\t\n\t            // no grouping separator and no currency sign\n\t\n\t\n\t            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n\t                var _leftLength$split = leftLength.split(settingsClone.aDec),\n\t                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n\t                    subParts = _leftLength$split2[0];\n\t\n\t                var nSign = '';\n\t                if (contains(subParts, '-')) {\n\t                    nSign = '-';\n\t                    subParts = subParts.replace('-', '');\n\t                    left = left.replace('-', '');\n\t                }\n\t\n\t                // strip leading zero on positive value if need\n\t                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n\t                    left = left.slice(1);\n\t                }\n\t\n\t                // strip leading zero on negative value if need\n\t                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n\t                    left = left.slice(1);\n\t                }\n\t                left = nSign + left;\n\t            }\n\t\n\t            var value = autoGroup(this.value, this.settingsClone);\n\t            var position = value.length;\n\t            if (value) {\n\t                // prepare regexp which searches for cursor position from unformatted left part\n\t                var leftAr = left.split('');\n\t\n\t                // fixes caret position with trailing minus sign\n\t                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n\t                    leftAr.shift();\n\t                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                        leftAr.push('-');\n\t                        settingsClone.caretFix = e.type === 'keydown';\n\t                    }\n\t                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                        leftAr.push('-');\n\t                        settingsClone.caretFix = e.type === 'keydown';\n\t                    }\n\t                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                        (function () {\n\t                            var signParts = settingsClone.aSign.split('');\n\t                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n\t                            var escapedParts = [];\n\t                            $.each(signParts, function (i, miniParts) {\n\t                                miniParts = signParts[i];\n\t                                if (isInArray(miniParts, escapeChr)) {\n\t                                    escapedParts.push('\\\\' + miniParts);\n\t                                } else {\n\t                                    escapedParts.push(miniParts);\n\t                                }\n\t                            });\n\t                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n\t                                escapedParts.push('-');\n\t                            }\n\t\n\t                            // pushing the escaped sign\n\t                            leftAr.push(escapedParts.join(''));\n\t                            settingsClone.caretFix = e.type === 'keydown';\n\t                        })();\n\t                    }\n\t                }\n\t\n\t                for (var i = 0; i < leftAr.length; i++) {\n\t                    if (!leftAr[i].match('\\\\d')) {\n\t                        leftAr[i] = '\\\\' + leftAr[i];\n\t                    }\n\t                }\n\t\n\t                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\t\n\t                // search cursor position in formatted value\n\t                var newLeft = value.match(leftReg);\n\t                if (newLeft) {\n\t                    position = newLeft[0].length;\n\t\n\t                    // if we are just before sign which is in prefix position\n\t                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n\t                        // place caret after prefix sign\n\t                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n\t                    }\n\t                } else {\n\t                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n\t                        // if we could not find a place for cursor and have a sign as a suffix\n\t                        // place caret before suffix currency sign\n\t                        position -= settingsClone.aSign.length;\n\t                    }\n\t                    if (settingsClone.aSuffix) {\n\t                        // if we could not find a place for cursor and have a suffix\n\t                        // place caret before suffix\n\t                        position -= settingsClone.aSuffix.length;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.that.value = value;\n\t            this.setPosition(position);\n\t            this.formatted = true;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n\t     *\n\t     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n\t     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n\t     *\n\t     * It then loops through the string and un-formats the inputs with autoNumeric.\n\t     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n\t     *\n\t     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n\t     * @param that - A reference to the current DOM element\n\t     * @returns {*}\n\t     * @private\n\t     */\n\t    function _getStringOrArray() {\n\t        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t        var that = arguments[1];\n\t\n\t        var $this = autoGet(that);\n\t        var formIndex = $('form').index($this);\n\t        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n\t        var aiIndex = [];\n\t\n\t        // all input index\n\t        var scIndex = [];\n\t\n\t        // successful control index\n\t        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\t\n\t        // from jQuery serialize method\n\t        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\t        // from jQuery serialize method\n\t        var rCheckableType = /^(?:checkbox|radio)$/i;\n\t        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\t\n\t        var count = 0;\n\t\n\t        // index of successful elements\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n\t                scIndex.push(count);\n\t                count++;\n\t            } else {\n\t                scIndex.push(-1);\n\t            }\n\t        });\n\t\n\t        // index of all inputs tags except checkbox\n\t        count = 0;\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n\t                aiIndex.push(count);\n\t                count++;\n\t            } else {\n\t                aiIndex.push(-1);\n\t                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n\t                    count++;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (getArrayBehavior) {\n\t            var formFields = $this.serializeArray();\n\t\n\t            $.each(formFields, function (i, field) {\n\t                var scElement = $.inArray(i, scIndex);\n\t\n\t                if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                    var settings = testInput.data('autoNumeric');\n\t\n\t                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                        field.value = testInput.autoNumeric('getLocalized').toString();\n\t                    }\n\t                }\n\t            });\n\t\n\t            return formFields;\n\t        } else {\n\t            var _ret2 = function () {\n\t                // getString() behavior\n\t                var formFields = $this.serialize();\n\t                var formParts = formFields.split('&');\n\t\n\t                $.each(formParts, function (i) {\n\t                    var _formParts$i$split = formParts[i].split('='),\n\t                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n\t                        inputName = _formParts$i$split2[0],\n\t                        inputValue = _formParts$i$split2[1];\n\t\n\t                    var scElement = $.inArray(i, scIndex);\n\t\n\t                    // If the current element is a valid element\n\t                    if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                        var settings = testInput.data('autoNumeric');\n\t\n\t                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                            if (inputValue !== null) {\n\t                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n\t                                formParts[i] = inputName + '=' + modifiedInputValue;\n\t                            }\n\t                        }\n\t                    }\n\t                });\n\t\n\t                return {\n\t                    v: formParts.join('&')\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'focusin' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onFocusInAndMouseEnter($this, holder) {\n\t        $this.on('focusin.autoNumeric mouseenter.autoNumeric', function (e) {\n\t            holder = getHolder($this);\n\t            var $settings = holder.settingsClone;\n\t            if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && $settings.wEmpty === 'focus') {\n\t                $settings.onOff = true;\n\t\n\t                if ($settings.nBracket !== null && $settings.aNeg !== '') {\n\t                    $this.val(negativeBracket($this.val(), $settings));\n\t                }\n\t\n\t                var result = void 0;\n\t                if ($settings.eDec) {\n\t                    $settings.mDec = $settings.eDec;\n\t                    $this.autoNumeric('set', $settings.rawValue);\n\t                } else if ($settings.scaleDivisor) {\n\t                    $settings.mDec = $settings.oDec;\n\t                    $this.autoNumeric('set', $settings.rawValue);\n\t                } else if ($settings.nSep) {\n\t                    $settings.aSep = '';\n\t                    $settings.aSign = '';\n\t                    $settings.aSuffix = '';\n\t                    $this.autoNumeric('set', $settings.rawValue);\n\t                } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n\t                    $this.autoNumeric('set', result);\n\t                }\n\t\n\t                holder.inVal = $this.val();\n\t                holder.lastVal = holder.inVal;\n\t                var onEmpty = checkEmpty(holder.inVal, $settings, true);\n\t                if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n\t                    $this.val(onEmpty);\n\t                }\n\t            }\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keydown' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onKeydown($this, holder) {\n\t        $this.on('keydown.autoNumeric', function (e) {\n\t            holder = getHolder($this);\n\t            if (holder.that.readOnly) {\n\t                holder.processed = true;\n\t\n\t                return true;\n\t            }\n\t            /* // The code below allows the \"enter\" keydown to throw a change() event\n\t             if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n\t             $this.change();\n\t             holder.inVal = $this.val();\n\t             } */\n\t            holder.init(e);\n\t            if (holder.skipAlways(e)) {\n\t                holder.processed = true;\n\t\n\t                return true;\n\t            }\n\t            if (holder.processAlways()) {\n\t                holder.processed = true;\n\t                holder.formatQuick(e);\n\t                var currentValue = $this.val();\n\t                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                    // throws input event in deletion character\n\t                    $this.trigger('input');\n\t                }\n\t                holder.lastVal = currentValue;\n\t                holder.settingsClone.throwInput = true;\n\t                e.preventDefault();\n\t\n\t                return false;\n\t            }\n\t            holder.formatted = false;\n\t\n\t            return true;\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keypress' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onKeypress($this, holder) {\n\t        $this.on('keypress.autoNumeric', function (e) {\n\t            // Firefox fix for Shift && insert paste event\n\t            if (e.shiftKey && e.keyCode === keyCode.Insert) {\n\t                return;\n\t            }\n\t            holder = getHolder($this);\n\t            var processed = holder.processed;\n\t            holder.init(e);\n\t\n\t            if (holder.skipAlways(e)) {\n\t                return true;\n\t            }\n\t\n\t            if (processed) {\n\t                e.preventDefault();\n\t\n\t                return false;\n\t            }\n\t\n\t            if (holder.processAlways() || holder.processKeypress()) {\n\t                holder.formatQuick(e);\n\t                var currentValue = $this.val();\n\t                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                    // throws input event on adding character\n\t                    $this.trigger('input');\n\t                }\n\t                holder.lastVal = currentValue;\n\t                holder.settingsClone.throwInput = true;\n\t                e.preventDefault();\n\t\n\t                return;\n\t            }\n\t            holder.formatted = false;\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keyup' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @param settings\n\t     * @returns {*}\n\t     */\n\t    function onKeyup($this, holder, settings) {\n\t        $this.on('keyup.autoNumeric', function (e) {\n\t            holder = getHolder($this);\n\t            holder.init(e);\n\t            var skip = holder.skipAlways(e);\n\t            var tab = holder.kdCode;\n\t            holder.kdCode = 0;\n\t            delete holder.valuePartsBeforePaste;\n\t\n\t            // added to properly place the caret when only the currency sign is present\n\t            if ($this[0].value === holder.settingsClone.aSign) {\n\t                if (holder.settingsClone.pSign === 's') {\n\t                    setElementSelection(this, 0, 0);\n\t                } else {\n\t                    setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n\t                }\n\t            } else if (tab === keyCode.Tab) {\n\t                setElementSelection(this, 0, $this.val().length);\n\t            }\n\t\n\t            if ($this[0].value === holder.settingsClone.aSuffix) {\n\t                setElementSelection(this, 0, 0);\n\t            }\n\t\n\t            if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n\t                setElementSelection(this, 0, 0);\n\t            }\n\t\n\t            // saves the extended decimal to preserve the data when navigating away from the page\n\t            if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n\t                autoSave($this, settings, 'set');\n\t            }\n\t            if (skip) {\n\t                return true;\n\t            }\n\t            if (this.value === '') {\n\t                return true;\n\t            }\n\t            if (!holder.formatted) {\n\t                holder.formatQuick(e);\n\t            }\n\t        });\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'focusout' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onFocusOutAndMouseLeave($this, holder) {\n\t        $this.on('focusout.autoNumeric mouseleave.autoNumeric', function () {\n\t            if (!$this.is(':focus')) {\n\t                holder = getHolder($this);\n\t                var value = $this.val();\n\t                var origValue = value;\n\t                var settings = holder.settingsClone;\n\t                settings.onOff = false;\n\t                if (settings.aStor) {\n\t                    autoSave($this, settings, 'set');\n\t                }\n\t\n\t                if (settings.nSep === true) {\n\t                    settings.aSep = settings.oSep;\n\t                    settings.aSign = settings.oSign;\n\t                    settings.aSuffix = settings.oSuffix;\n\t                }\n\t\n\t                if (settings.eDec !== null) {\n\t                    settings.mDec = settings.oDec;\n\t                    settings.aPad = settings.oPad;\n\t                    settings.nBracket = settings.oBracket;\n\t                }\n\t\n\t                value = autoStrip(value, settings);\n\t                if (value !== '') {\n\t                    if (settings.trailingNegative) {\n\t                        value = '-' + value;\n\t                        settings.trailingNegative = false;\n\t                    }\n\t\n\t                    var _autoCheck3 = autoCheck(value, settings),\n\t                        _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n\t                        minTest = _autoCheck4[0],\n\t                        maxTest = _autoCheck4[1];\n\t\n\t                    if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n\t                        value = fixNumber(value, settings);\n\t                        settings.rawValue = value;\n\t\n\t                        if (settings.scaleDivisor) {\n\t                            value = value / settings.scaleDivisor;\n\t                            value = value.toString();\n\t                        }\n\t\n\t                        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? +settings.scaleDecimal : settings.mDec;\n\t                        value = autoRound(value, settings);\n\t                        value = presentNumber(value, settings);\n\t                    } else {\n\t                        if (!minTest) {\n\t                            $this.trigger('autoNumeric:minExceeded');\n\t                        }\n\t                        if (!maxTest) {\n\t                            $this.trigger('autoNumeric:maxExceeded');\n\t                        }\n\t\n\t                        value = settings.rawValue;\n\t                    }\n\t                } else {\n\t                    if (settings.wEmpty === 'zero') {\n\t                        settings.rawValue = '0';\n\t                        value = autoRound('0', settings);\n\t                    } else {\n\t                        settings.rawValue = '';\n\t                    }\n\t                }\n\t\n\t                var groupedValue = checkEmpty(value, settings, false);\n\t                if (groupedValue === null) {\n\t                    groupedValue = autoGroup(value, settings);\n\t                }\n\t\n\t                if (groupedValue !== origValue) {\n\t                    groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n\t                    $this.val(groupedValue);\n\t                }\n\t\n\t                if (groupedValue !== holder.inVal) {\n\t                    $this.change();\n\t                    delete holder.inVal;\n\t                }\n\t            }\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'paste' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onPaste($this, holder) {\n\t        $this.on('paste', function (e) {\n\t            //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n\t            e.preventDefault();\n\t            holder = getHolder($this);\n\t\n\t            var oldRawValue = $this.autoNumeric('get');\n\t            var currentValue = this.value || '';\n\t            var selectionStart = this.selectionStart || 0;\n\t            var selectionEnd = this.selectionEnd || 0;\n\t            var prefix = currentValue.substring(0, selectionStart);\n\t            var suffix = currentValue.substring(selectionEnd, currentValue.length);\n\t            var pastedText = preparePastedText(e.originalEvent.clipboardData.getData('text/plain'), holder);\n\t\n\t            if (isValidPasteText(pastedText)) {\n\t                var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\t\n\t                if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n\t                    $this.autoNumeric('set', newValue);\n\t                    $this.trigger('input');\n\t                }\n\t            } else {\n\t                this.selectionStart = selectionEnd;\n\t            }\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'submit' events\n\t     *\n\t     * @param $this\n\t     * @param holder\n\t     * @returns {*}\n\t     */\n\t    function onSubmit($this, holder) {\n\t        $this.closest('form').on('submit.autoNumeric', function () {\n\t            holder = getHolder($this);\n\t\n\t            if (holder) {\n\t                var $settings = holder.settingsClone;\n\t\n\t                if ($settings.unSetOnSubmit) {\n\t                    $this.val($settings.rawValue);\n\t                }\n\t            }\n\t        });\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n\t     *\n\t     * @param $this\n\t     * @returns {boolean|*}\n\t     */\n\t    function getInputIfSupportedTagAndType($this) {\n\t        // Supported input type\n\t        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t        // Checks for non-supported input types\n\t        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n\t            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n\t        }\n\t\n\t        // Checks for non-supported tags\n\t        var currentElementTag = $this.prop('tagName').toLowerCase();\n\t        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n\t            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n\t        }\n\t\n\t        return $input;\n\t    }\n\t\n\t    /**\n\t     * Routine to format the default value on page load\n\t     *\n\t     * @param settings\n\t     * @param $input\n\t     * @param $this\n\t     */\n\t    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n\t        var setValue = true;\n\t\n\t        if ($input) {\n\t            var currentValue = $this.val();\n\t            /*\n\t             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n\t             * precedence and should get formatted on init (if this input value is a valid number and that the\n\t             * developer wants it formatted on init (cf. `settings.aForm`)).\n\t             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n\t             *\n\t             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n\t             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n\t             * changed the input value, and then it means we should not overwrite his own decision to do so.\n\t             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n\t             * we should ignore `anDefault` altogether.\n\t             */\n\t            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n\t                // Check if the `value` is valid or not\n\t                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n\t                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n\t                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n\t                    $this.autoNumeric('set', testedCurrentValue);\n\t                    setValue = false;\n\t                } else {\n\t                    // If not, inform the developer that nothing usable has been provided\n\t                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n\t                }\n\t            } else {\n\t                /* Checks for :\n\t                 * - page reload from back button, and\n\t                 * - ASP.net form post back\n\t                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n\t                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n\t                 */\n\t                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n\t                if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n\t                    if (settings.eDec !== null && settings.aStor || settings.scaleDivisor && settings.aStor) {\n\t                        settings.rawValue = autoSave($this, settings, 'get');\n\t                    }\n\t\n\t                    // If the eDec value should NOT be saved in sessionStorage\n\t                    if (!settings.aStor) {\n\t                        var toStrip = void 0;\n\t\n\t                        if (settings.nBracket !== null && settings.aNeg !== '') {\n\t                            settings.onOff = true;\n\t                            toStrip = negativeBracket(currentValue, settings);\n\t                        } else {\n\t                            toStrip = currentValue;\n\t                        }\n\t\n\t                        settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n\t                    }\n\t\n\t                    setValue = false;\n\t                }\n\t            }\n\t\n\t            if (currentValue === '') {\n\t                switch (settings.wEmpty) {\n\t                    case 'focus':\n\t                        setValue = false;\n\t                        break;\n\t                    case 'always':\n\t                        $this.val(settings.aSign);\n\t                        setValue = false;\n\t                        break;\n\t                    case 'zero':\n\t                        $this.autoNumeric('set', '0');\n\t                        setValue = false;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (setValue && currentValue === $this.attr('value')) {\n\t                $this.autoNumeric('set', currentValue);\n\t            }\n\t        }\n\t\n\t        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n\t            if (settings.anDefault !== null) {\n\t                if (settings.anDefault === $this.text()) {\n\t                    $this.autoNumeric('set', $this.text());\n\t                }\n\t            } else {\n\t                $this.autoNumeric('set', $this.text());\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Enhance the user experience by modifying the default `pNeg` option depending on `aSign` and `pSign`.\n\t     *\n\t     * If the user has not set the placement of the negative sign (`pNeg`), but has set a currency symbol (`aSign`),\n\t     * then we modify the default value of `pNeg` in order to keep the resulting output logical by default :\n\t     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({aSign: \"$\", pNeg: \"r\"})\n\t     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({aSign: \"$\", pSign: \"s\", pNeg: \"p\"})\n\t     *\n\t     * @param {object} options\n\t     * @param {object} settings\n\t     */\n\t    function correctPNegOption(options, settings) {\n\t        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.pNeg) && options.aSign !== '') {\n\t            switch (settings.pSign) {\n\t                case 's':\n\t                    settings.pNeg = 'p';\n\t                    break;\n\t                case 'p':\n\t                    settings.pNeg = 'r';\n\t                    break;\n\t                default:\n\t                //\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n\t     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n\t     *\n\t     * @param options\n\t     * @param $this\n\t     * @returns {object|null}\n\t     */\n\t    function getInitialSettings(options, $this) {\n\t        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n\t        var settings = $this.data('autoNumeric');\n\t\n\t        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n\t        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t            // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n\t            var tagData = $this.data();\n\t\n\t            settings = $.extend({}, defaultSettings, tagData, options, {\n\t                onOff: false,\n\t                runOnce: false,\n\t                rawValue: '',\n\t                trailingNegative: false,\n\t                caretFix: false,\n\t                throwInput: true,\n\t                strip: true,\n\t                tagList: allowedTagList\n\t            });\n\t\n\t            // Modify the user settings to make them 'exploitable'\n\t            $.each(settings, function (key, value) {\n\t                // Convert the string 'true' and 'false' to real Boolean\n\t                if (value === 'true' || value === 'false') {\n\t                    settings[key] = value === 'true';\n\t                }\n\t\n\t                // Convert numbers in options to strings\n\t                //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n\t                if (typeof value === 'number' && key !== 'aScale') {\n\t                    settings[key] = value.toString();\n\t                }\n\t            });\n\t\n\t            // Improve the `pNeg` option if needed\n\t            correctPNegOption(options, settings);\n\t\n\t            // Set the negative sign\n\t            settings.aNeg = settings.vMin < 0 ? '-' : '';\n\t\n\t            // Validate the settings\n\t            validate(settings, false); // Throws if necessary\n\t\n\t            // Save our new settings\n\t            $this.data('autoNumeric', settings);\n\t\n\t            return settings;\n\t        } else {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Methods supported by autoNumeric\n\t     */\n\t    var methods = {\n\t        /**\n\t         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n\t         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n\t         *\n\t         * @example\n\t         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n\t         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n\t         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n\t         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n\t         */\n\t        init: function init(options) {\n\t            return this.each(function () {\n\t                var $this = $(this);\n\t                var $input = getInputIfSupportedTagAndType($this);\n\t\n\t                var settings = getInitialSettings(options, $this);\n\t                if (isNull(settings)) {\n\t                    return this;\n\t                }\n\t\n\t                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n\t                keepOriginalSettings(settings);\n\t                var holder = getHolder($this, settings);\n\t\n\t                //TODO Shouldn't the next line be in the `getInitialSettings()` function?\n\t                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\t\n\t                if (settings.runOnce === false && settings.aForm) {\n\t                    formatDefaultValueOnPageLoad(settings, $input, $this);\n\t                }\n\t\n\t                settings.runOnce = true;\n\t\n\t                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n\t                if ($input) {\n\t                    holder = onFocusInAndMouseEnter($this, holder);\n\t                    holder = onFocusOutAndMouseLeave($this, holder);\n\t                    holder = onKeydown($this, holder);\n\t                    holder = onKeypress($this, holder);\n\t                    holder = onKeyup($this, holder, settings);\n\t                    holder = onPaste($this, holder);\n\t                    onSubmit($this, holder);\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * method to remove settings and stop autoNumeric() - does not remove the formatting\n\t         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n\t         * no parameters accepted\n\t         */\n\t        destroy: function destroy() {\n\t            return $(this).each(function () {\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    autoSave($this, settings, 'wipe');\n\t                    $this.removeData('autoNumeric');\n\t                    $this.off('.autoNumeric');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * method to clear the value and sessionStorage or cookie depending on browser supports\n\t         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n\t         * no parameters accepted\n\t         */\n\t        wipe: function wipe() {\n\t            return $(this).each(function () {\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    settings.rawValue = '';\n\t                    autoSave($this, settings, 'wipe');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method that updates the autoNumeric settings\n\t         * It can be called multiple times if needed\n\t         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n\t         *\n\t         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n\t         */\n\t        update: function update(options) {\n\t            return $(this).each(function () {\n\t                //TODO Replace all this duplicated code with a call to `getInitialSettings()`\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method');\n\t                }\n\t                var strip = $this.autoNumeric('get');\n\t                settings = $.extend(settings, options);\n\t\n\t                if (settings.scaleDivisor) {\n\t                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\t                }\n\t                keepOriginalSettings(settings);\n\t                getHolder($this, settings, true);\n\t\n\t                if (settings.aDec === settings.aSep) {\n\t                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character');\n\t                }\n\t\n\t                // Improve the `pNeg` option if needed\n\t                correctPNegOption(options, settings);\n\t\n\t                $this.data('autoNumeric', settings);\n\t\n\t                if ($this.val() !== '' || $this.text() !== '') {\n\t                    return $this.autoNumeric('set', strip);\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to format the value passed as a parameter.\n\t         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n\t         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n\t         * and must contain only numbers and one decimal (period) character\n\t         *\n\t         * @param {*} newValue\n\t         * @returns {*|jQuery}\n\t         */\n\t        set: function set(newValue) {\n\t            return $(this).each(function () {\n\t                if (newValue === null || isUndefined(newValue)) {\n\t                    return;\n\t                }\n\t\n\t                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t                var value = newValue.toString();\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n\t                }\n\t\n\t                // allows locale decimal separator to be a comma - no thousand separator allowed\n\t                value = fromLocale(value);\n\t\n\t                // Throws an error if the value being set is not numeric\n\t                if (!$.isNumeric(Number(value))) {\n\t                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (value !== '') {\n\t                    var _autoCheck5 = autoCheck(value, settings),\n\t                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n\t                        minTest = _autoCheck6[0],\n\t                        maxTest = _autoCheck6[1];\n\t\n\t                    if (minTest && maxTest) {\n\t                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n\t                            settings.rawValue = value;\n\t                        }\n\t\n\t                        // checks if the value falls within the min max range\n\t                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                            if (settings.scaleDivisor && !settings.onOff) {\n\t                                value = value / settings.scaleDivisor;\n\t                                value = value.toString();\n\t                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\t                            }\n\t\n\t                            value = autoRound(value, settings);\n\t                            if (settings.eDec === null && settings.scaleDivisor === null) {\n\t                                settings.rawValue = value;\n\t                            }\n\t\n\t                            value = presentNumber(value, settings);\n\t                            value = autoGroup(value, settings);\n\t                        }\n\t\n\t                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n\t                            autoSave($this, settings, 'set');\n\t                        }\n\t                    } else {\n\t                        settings.rawValue = '';\n\t                        autoSave($this, settings, 'wipe');\n\t                        var attemptedValue = value;\n\t                        value = '';\n\t                        if (!minTest) {\n\t                            $this.trigger('autoNumeric:minExceeded');\n\t                        }\n\t\n\t                        if (!maxTest) {\n\t                            $this.trigger('autoNumeric:maxExceeded');\n\t                        }\n\t\n\t                        throwError('The value [' + attemptedValue + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n\t\n\t                        return $this.val('');\n\t                    }\n\t                } else {\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (!settings.onOff && settings.scaleSymbol) {\n\t                    value = value + settings.scaleSymbol;\n\t                }\n\t\n\t                if ($input) {\n\t                    return $this.val(value);\n\t                }\n\t\n\t                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                    return $this.text(value);\n\t                }\n\t\n\t                return false;\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * method to un-format inputs - handy to use right before form submission\n\t         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n\t         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n\t         */\n\t        unSet: function unSet() {\n\t            return $(this).each(function () {\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    settings.onOff = true;\n\t                    $this.val($this.autoNumeric('getLocalized'));\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * method to re-format inputs - handy to use right after form submission\n\t         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n\t         * this is called after the 'unSet' method to reformat the input\n\t         */\n\t        reSet: function reSet() {\n\t            return $(this).each(function () {\n\t                var $this = autoGet(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.autoNumeric('set', $this.val());\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Return the unformatted value as a string.\n\t         *\n\t         * @usage $(someSelector).autoNumeric('get');\n\t         *\n\t         * @returns {string}\n\t         */\n\t        get: function get() {\n\t            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n\t            var $this = autoGet(this);\n\t            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t            var settings = $this.data('autoNumeric');\n\t            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                throwError('Initializing autoNumeric is required prior to calling the \"get\" method');\n\t            }\n\t\n\t            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n\t            var value = '';\n\t            if ($input) {\n\t                value = $this.eq(0).val();\n\t            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                value = $this.eq(0).text();\n\t            } else {\n\t                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n\t            }\n\t\n\t            if (settings.eDec || settings.scaleDivisor) {\n\t                value = settings.rawValue;\n\t            } else {\n\t                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n\t                    return '';\n\t                }\n\t\n\t                if (value !== '' && settings.nBracket !== null) {\n\t                    settings.onOff = true;\n\t                    value = negativeBracket(value, settings);\n\t                }\n\t\n\t                if (settings.runOnce || settings.aForm === false) {\n\t                    value = autoStrip(value, settings);\n\t                }\n\t\n\t                value = fixNumber(value, settings);\n\t            }\n\t\n\t            // Always return a numeric string\n\t            return value;\n\t        },\n\t\n\t\n\t        /**\n\t         * Returns the unformatted value, but following the `outputType` setting, which means the output can either be :\n\t         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n\t         * - a plain number (if the setting 'number' is used).\n\t         *\n\t         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n\t         * Check the \"outputType\" option definition for more details.\n\t         *\n\t         * @returns {*}\n\t         */\n\t        getLocalized: function getLocalized() {\n\t            var $this = autoGet(this);\n\t            var value = $this.autoNumeric('get');\n\t            var settings = $this.data('autoNumeric');\n\t\n\t            if (Number(value) === 0 && settings.lZero !== 'keep') {\n\t                value = '0';\n\t            }\n\t\n\t            return toLocale(value, settings.outputType);\n\t        },\n\t\n\t\n\t        /**\n\t         * Return the current formatted value of the autoNumeric element.\n\t         * @usage aNInput.autoNumeric('getFormatted'))\n\t         *\n\t         * @returns {string}\n\t         */\n\t        getFormatted: function getFormatted() {\n\t            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n\t            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n\t                throwError('Unable to get the formatted string from the element.');\n\t            }\n\t\n\t            return this[0].value;\n\t        },\n\t\n\t\n\t        /**\n\t         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n\t         *\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n\t         */\n\t        getString: function getString() {\n\t            return _getStringOrArray(false, this);\n\t        },\n\t\n\t\n\t        /**\n\t         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n\t         *\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n\t         */\n\t        getArray: function getArray() {\n\t            return _getStringOrArray(true, this);\n\t        },\n\t\n\t\n\t        /**\n\t         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n\t         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n\t         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n\t         */\n\t        getSettings: function getSettings() {\n\t            var $this = autoGet(this);\n\t\n\t            return $this.eq(0).data('autoNumeric');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n\t     * It initialize autoNumeric on the given element.\n\t     */\n\t    $.fn.autoNumeric = function (method) {\n\t        if (methods[method]) {\n\t            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                args[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            return methods[method].apply(this, args);\n\t        }\n\t\n\t        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n\t            // The options have been passed directly, without using a named method\n\t            return methods.init.apply(this, [method]);\n\t        }\n\t\n\t        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n\t    };\n\t\n\t    /**\n\t     * Return the default autoNumeric settings.\n\t     *\n\t     * @return {object}\n\t     */\n\t    getDefaultConfig = function getDefaultConfig() {\n\t        return defaultSettings;\n\t    };\n\t\n\t    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\t\n\t    /**\n\t     * Public function that allows formatting without an element trigger\n\t     */\n\t    autoFormat = function autoFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        value = value.toString();\n\t        value = fromLocale(value);\n\t        if (Number(value) < 0) {\n\t            settings.aNeg = '-'; //TODO Replace this with `getInitialSettings()` that already sets `aNeg`?\n\t        }\n\t\n\t        if (settings.mDec === null) {\n\t            var vMax = settings.vMax.toString().split('.');\n\t            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n\t            settings.mDec = decLength(vMin, vMax);\n\t        }\n\t\n\t        var _autoCheck7 = autoCheck(value, settings),\n\t            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n\t            minTest = _autoCheck8[0],\n\t            maxTest = _autoCheck8[1];\n\t\n\t        if (!minTest || !maxTest) {\n\t            // Throw a custom event\n\t            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n\t            throwError('The value [' + value + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n\t        }\n\t        value = autoRound(value, settings);\n\t        value = presentNumber(value, settings);\n\t        value = autoGroup(value, settings);\n\t\n\t        return value;\n\t    };\n\t\n\t    $.fn.autoFormat = autoFormat;\n\t\n\t    /**\n\t     * Public function that allows unformatting without an element\n\t     */\n\t    autoUnFormat = function autoUnFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        var allowed = '-0123456789\\\\' + settings.aDec;\n\t        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        value = value.toString();\n\t\n\t        if (value.charAt(0) === '-') {\n\t            settings.aNeg = '-';\n\t        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n\t            settings.aNeg = '-';\n\t            settings.onOff = true;\n\t            value = negativeBracket(value, settings);\n\t        }\n\t\n\t        value = value.replace(autoStrip, '');\n\t        value = value.replace(',', '.');\n\t        value = toLocale(value, settings.outputType);\n\t\n\t        return value;\n\t    };\n\t\n\t    $.fn.autoUnformat = autoUnFormat;\n\t\n\t    /**\n\t     * Validate the given option object.\n\t     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n\t     *\n\t     * This tests if the options are not conflicting and are well formatted.\n\t     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n\t     *\n\t     * @param {*} userOptions\n\t     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n\t     * @throws Error\n\t     */\n\t    validate = function validate(userOptions) {\n\t        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\t\n\t        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n\t            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n\t        }\n\t\n\t        // The user can choose if the `userOptions` has already been extended with the default options, or not\n\t        var options = void 0;\n\t        if (shouldExtendDefaultOptions) {\n\t            options = $.extend({}, defaultSettings, userOptions);\n\t        } else {\n\t            options = userOptions;\n\t        }\n\t\n\t        var testPositiveInteger = /^[0-9]+$/;\n\t        var testNumericalCharacters = /[0-9]+/;\n\t        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n\t        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n\t        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\t\n\t        // Then tests the options individually\n\t        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n\t            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n\t            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.');\n\t        }\n\t\n\t        if (!testPositiveInteger.test(options.dGroup)) {\n\t            // isNaN(parseInt(options.dGroup)) //DEBUG\n\t            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.aDec, [',', '.'])) {\n\t            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.');\n\t        }\n\t\n\t        // Checks if the decimal and thousand characters are the same\n\t        if (options.aDec === options.aSep) {\n\t            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.');\n\t        }\n\t\n\t        if (!isNull(options.altDec) && !isString(options.altDec)) {\n\t            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.');\n\t        }\n\t\n\t        if (options.aSign !== '' && !isString(options.aSign)) {\n\t            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.pSign, ['p', 's'])) {\n\t            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n\t            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.');\n\t        }\n\t\n\t        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n\t            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n\t            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.');\n\t        }\n\t\n\t        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n\t            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.');\n\t        }\n\t\n\t        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n\t            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.');\n\t        }\n\t\n\t        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n\t            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].');\n\t        }\n\t\n\t        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n\t            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.');\n\t        }\n\t\n\t        if (!options.aPad && !isNull(options.mDec)) {\n\t            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n\t        }\n\t\n\t        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n\t        var dpVMin = decimalPlaces(options.vMin);\n\t        var dpVMax = decimalPlaces(options.vMax);\n\t        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n\t        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n\t        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n\t        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n\t            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n\t        }\n\t\n\t        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n\t            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.');\n\t        }\n\t\n\t        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n\t        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n\t            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.');\n\t        }\n\t\n\t        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n\t            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n\t            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n\t            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n\t            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n\t            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n\t            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n\t            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n\t            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n\t            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n\t            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n\t            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n\t            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n\t            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.outputType) && !isInArray(options.outputType, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n\t            throwError('The custom locale format option \\'outputType\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputType + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n\t            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.');\n\t        }\n\t    };\n\t\n\t    $.fn.validate = validate;\n\t\n\t    /**\n\t     * Return TRUE is the settings/options are valid, FALSE otherwise.\n\t     *\n\t     * @param {object} options\n\t     * @returns {boolean}\n\t     */\n\t    areSettingsValid = function areSettingsValid(options) {\n\t        var isValid = true;\n\t        try {\n\t            validate(options);\n\t        } catch (error) {\n\t            isValid = false;\n\t        }\n\t\n\t        return isValid;\n\t    };\n\t\n\t    /**\n\t     * Create a custom event.\n\t     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n\t     *\n\t     * @param eventName string\n\t     * @param detail\n\t     * @returns {CustomEvent}\n\t     */\n\t    function createCustomEvent(eventName, detail) {\n\t        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n\t    }\n\t\n\t    /**\n\t     * Create a custom event and immediately broadcast it.\n\t     *\n\t     * @param eventName string\n\t     * @param detail\n\t     * @returns {boolean}\n\t     */\n\t    function sendCustomEvent(eventName) {\n\t        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t        return document.dispatchEvent(createCustomEvent(eventName, detail));\n\t    }\n\t\n\t    /**\n\t     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n\t     */\n\t    (function () {\n\t        if (typeof window.CustomEvent === 'function') {\n\t            return false;\n\t        }\n\t\n\t        function CustomEvent(event, params) {\n\t            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n\t            var evt = document.createEvent('CustomEvent');\n\t            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t            return evt;\n\t        }\n\t\n\t        CustomEvent.prototype = window.Event.prototype;\n\t        window.CustomEvent = CustomEvent;\n\t    })();\n\t});\n\t\n\t/**\n\t * This exports the interface for the autoNumeric object\n\t */\n\texports.default = {\n\t    format: autoFormat,\n\t    unFormat: autoUnFormat,\n\t    getDefaultConfig: getDefaultConfig,\n\t    validate: validate, // an.validate(options) : throws if necessary\n\t    areSettingsValid: areSettingsValid };\n\t}.call(window));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// autoNumeric.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cef88720a77bb27dabf5","/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-12-01 UTC 21:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nlet autoFormat;\nlet autoUnFormat;\nlet getDefaultConfig;\nlet validate;\nlet areSettingsValid;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nconst allowedTagList = [\n    'b',\n    'caption',\n    'cite',\n    'code',\n    'const',\n    'dd',\n    'del',\n    'div',\n    'dfn',\n    'dt',\n    'em',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'ins',\n    'kdb',\n    'label',\n    'li',\n    'option',\n    'output',\n    'p',\n    'q',\n    's',\n    'sample',\n    'span',\n    'strong',\n    'td',\n    'th',\n    'u',\n];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nconst defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     */\n    aSep: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     */\n    nSep: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * dGroup: \"3\", results in 999,999,999 default\n     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n     */\n    dGroup: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     */\n    aDec: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     */\n    altDec: null,\n\n    /* aSign = allowed currency symbol\n     * Must be in quotes aSign: \"$\"\n     * space to the right of the currency symbol aSign: '$ '\n     * space to the left of the currency symbol aSign: ' $'\n     */\n    aSign: '',\n\n    /* pSign = placement of currency sign as a p=prefix or s=suffix\n     * for prefix pSign: \"p\" (default)\n     * for suffix pSign: \"s\"\n     */\n    pSign: 'p',\n\n    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {aSign: \"$\"}\n     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n     * 1,234.56-  => {pNeg: \"s\"}\n     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n     */\n    pNeg: 'l',\n\n    /* Additional suffix\n     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     */\n    aSuffix: '',\n\n    /* Override min max limits\n     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n     * oLimits: \"ignore\" ignores both vMin & vMax\n     */\n    oLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than vMin\n     */\n    vMax: '9999999999999.99',\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than vMax\n     */\n    vMin: '-9999999999999.99',\n\n    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n     * value must be enclosed in quotes example mDec: \"3\",\n     */\n    mDec: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     */\n    eDec: null,\n\n    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     */\n    scaleDecimal: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the eDec value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     */\n    aStor: false,\n\n    /* method used for rounding\n     * mRound: \"S\", Round-Half-Up Symmetric (default)\n     * mRound: \"A\", Round-Half-Up Asymmetric\n     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * mRound: \"U05\" Rounds up to next .05\n     * mRound: \"D05\" Rounds down to next .05\n     */\n    mRound: 'S',\n\n    /* Controls decimal padding\n     * aPad: true - always Pad decimals with zeros\n     * aPad: false - does not pad with zeros.\n     * Note: setting aPad to 'false' will override the 'mDec' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     */\n    aPad: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * nBracket: null - (default)\n     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n     */\n    nBracket: null,\n\n    /* Displayed on empty string \"\"\n     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n     * wEmpty: \"press\" - currency sign displays on any key being pressed\n     * wEmpty: \"always\" - always displays the currency sign only\n     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     */\n    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n    wEmpty: 'focus',\n\n    /* Controls leading zero behavior\n     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * lZero: \"deny\", - allows only one leading zero on values less than one\n     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     */\n    lZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value\n     */\n    aForm: true,\n\n    /* Determine if the select all keyboard command will select\n     * the complete input text or only the input numeric value\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n     */\n    sNumber: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {anDefault: \"\"}\n     * value=1234.56 {anDefault: '1234.56'}\n     */\n    anDefault: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     */\n    unSetOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     */\n    outputType: null,\n\n    /* Error handling function\n     * true => all errors are thrown - helpful in site development\n     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n     */\n    debug: false,\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nconst keyCode = {\n    Backspace:      8,\n    Tab:            9,\n    Enter:          13,\n    Shift:          16,\n    Ctrl:           17,\n    Alt:            18,\n    PauseBreak:     19,\n    CapsLock:       20,\n    Esc:            27,\n    Space:          32,\n    PageUp:         33,\n    PageDown:       34,\n    End:            35,\n    Home:           36,\n    LeftArrow:      37,\n    UpArrow:        38,\n    RightArrow:     39,\n    DownArrow:      40,\n    Insert:         45,\n    Delete:         46,\n    num0:           48,\n    num1:           49,\n    num2:           50,\n    num3:           51,\n    num4:           52,\n    num5:           53,\n    num6:           54,\n    num7:           55,\n    num8:           56,\n    num9:           57,\n    a:              65,\n    b:              66,\n    c:              67,\n    d:              68,\n    e:              69,\n    f:              70,\n    g:              71,\n    h:              72,\n    i:              73,\n    j:              74,\n    k:              75,\n    l:              76,\n    m:              77,\n    n:              78,\n    o:              79,\n    p:              80,\n    q:              81,\n    r:              82,\n    s:              83,\n    t:              84,\n    u:              85,\n    v:              86,\n    w:              87,\n    x:              88,\n    y:              89,\n    z:              90,\n    Windows:        91,\n    RightClick:     93,\n    numpad0:        96,\n    numpad1:        97,\n    numpad2:        98,\n    numpad3:        99,\n    numpad4:        100,\n    numpad5:        101,\n    numpad6:        102,\n    numpad7:        103,\n    numpad8:        104,\n    numpad9:        105,\n    MultiplyNumpad: 106,\n    PlusNumpad:     107,\n    MinusNumpad:    109,\n    DotNumpad:      110,\n    SlashNumpad:    111,\n    F1:             112,\n    F2:             113,\n    F3:             114,\n    F4:             115,\n    F5:             116,\n    F6:             117,\n    F7:             118,\n    F8:             119,\n    F9:             120,\n    F10:            121,\n    F11:            122,\n    F12:            123,\n    NumLock:        144,\n    ScrollLock:     145,\n    MyComputer:     182,\n    MyCalculator:   183,\n    Semicolon:      186,\n    Equal:          187,\n    Comma:          188,\n    Hyphen:         189,\n    Dot:            190,\n    Slash:          191,\n    Backquote:      192,\n    LeftBracket:    219,\n    Backslash:      220,\n    RightBracket:   221,\n    Quote:          222,\n    Command:        224,\n};\n\n\n(function(factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\nif (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n} else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n} else {\n    // Browser globals\n    factory(window.jQuery);\n}\n}($ => {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void(0);\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void(0) || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return (typeof str === 'string' || str instanceof String);\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof(value) === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        const lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return typeof reference === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (const prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the text given as a parameter is valid.\n     *\n     * @param text\n     * @returns {boolean}\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param text\n     * @param holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') { // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'object' && Object.prototype.toString.call(arr) === '[object Array]');\n        }\n        else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        const [, decimalPart] = str.split('.');\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        const [, decimalPart] = str.split('.');\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        const position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            const select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            const range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} suppressWarnings If TRUE, then the warning message is not displayed\n     */\n    function warning(message, suppressWarnings = false) {\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn(`Warning: ${message}`);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, (k, val) => {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        let vMaxLength = 0;\n        let vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        //TODO Merge `autoCode()` into `getInitialSettings()`\n        runCallbacks($this, settings);\n        const vMax = settings.vMax.toString().split('.');\n        const vMin = (!settings.vMin && settings.vMin !== 0) ? [] : settings.vMin.toString().split('.');\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = (settings.scaleDivisor && settings.scaleDecimal) ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        const aNegReg = settings.aNeg ?`([-\\\\${settings.aNeg}]?)` :'(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(`${aNegReg}[^-${(settings.aNeg?`\\\\${settings.aNeg}`:'')}\\\\${settings.aDec}\\\\d].*?(\\\\d|\\\\${settings.aDec}\\\\d)`);\n        settings.skipLastAutoStrip = new RegExp(`(\\\\d\\\\${settings.aDec}?)[^\\\\${settings.aDec}\\\\d]\\\\D*$`);\n        const allowed = `-0123456789\\\\${settings.aDec}`;\n        settings.allowedAutoStrip = new RegExp(`[^${allowed}]`, 'gi');\n        settings.numRegAutoStrip = new RegExp(`${aNegReg}(?:\\\\${settings.aDec}?(\\\\d+\\\\${settings.aDec}\\\\d+)|(\\\\d*(?:\\\\${settings.aDec}\\\\d*)?))`);\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || (settings.pSign === 's' && settings.pNeg !== 'p')) && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        const m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            let nSign = '';\n            const [integerPart, decimalPart] = s.split(settings.aDec);\n            let modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = `${nSign}${modifiedIntegerPart}${isUndefined(decimalPart)?'':settings.aDec + decimalPart}`;\n        }\n        if ((settings.onOff && settings.lZero === 'deny') || (settings.lZero === 'allow' && settings.onOff === false)) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            let stripReg = `^${settings.aNegRegAutoStrip}0*(\\\\d)`;\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Places or removes brackets on negative values\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function negativeBracket(s, settings) {\n        if ((settings.pSign === 'p' && settings.pNeg === 'l') || (settings.pSign === 's' && settings.pNeg === 'p')) {\n            const [firstBracket, lastBracket] = settings.nBracket.split(',');\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputType\" option definition for more details.\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        let result;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default :\n                throwError(`The given outputType [${locale}] option is not recognized.`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare number string to be converted to real number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function fixNumber(s, settings) {\n        if (settings.aDec !== '.') {\n            s = s.replace(settings.aDec, '.');\n        }\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace(settings.aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Prepare real number to be converted to our format\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return (settings.pNeg === 'l') ? inputValue + settings.aSign + settings.aSuffix : settings.aSign + inputValue + settings.aSuffix;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Private function that formats our number\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoGroup(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = autoStrip(inputValue, settings);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        const empty = checkEmpty(inputValue, settings, true);\n        const isNeg = contains(inputValue, '-');\n        if (isNeg) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (empty !== null) {\n            return empty;\n        }\n\n        let digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n        let [integerPart, decimalPart] = inputValue.split(settings.aDec);\n        if (settings.altDec && isUndefined(decimalPart)) {\n            [integerPart, decimalPart] = inputValue.split(settings.altDec);\n        }\n\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, `$1${settings.aSep}$2`);\n            }\n        }\n\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            inputValue = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            inputValue = integerPart;\n        }\n\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = settings.aNeg + settings.aSign + inputValue;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = settings.aSign + settings.aNeg + inputValue;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                inputValue = settings.aSign + inputValue + settings.aNeg;\n            }\n            if (!isNeg) {\n                inputValue = settings.aSign + inputValue;\n            }\n        }\n\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = inputValue + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = inputValue + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                inputValue = settings.aNeg + inputValue + settings.aSign;\n            }\n            if (!isNeg) {\n                inputValue = inputValue + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = negativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param rDec\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, rDec) {\n        let regex;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default :\n                // Removes access zeros to the mDec length when aPad is set to true\n                regex = new RegExp(`(\\\\.\\\\d{${rDec}}(?:\\\\d*[1-9])?)0*`);\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (rDec === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoRound(inputValue, settings) { // value to string\n        inputValue = (inputValue === '') ? '0' : inputValue.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default :\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            let result;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        let ivRounded = '';\n        let i = 0;\n        let nSign = '';\n        let rDec;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if ((Number(inputValue) > 0 && settings.lZero !== 'keep') || (inputValue.length > 0 && settings.lZero === 'allow')) {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        const dPos = inputValue.lastIndexOf('.');\n\n        // Virtual decimal position\n        const vdPos = (dPos === -1) ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        let cDec = (inputValue.length - 1) - vdPos;\n\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                let zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        const rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        const tRound = Number(inputValue.charAt(rLength + 1));\n        const odd = (inputValue.charAt(rLength) === '.') ? (inputValue.charAt(rLength - 1) % 2) : (inputValue.charAt(rLength) % 2);\n        let ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if ((tRound > 4 && settings.mRound === 'S')                  || // Round half up symmetric\n            (tRound > 4 && settings.mRound === 'A' && nSign === '')  || // Round half up asymmetric positive values\n            (tRound > 5 && settings.mRound === 'A' && nSign === '-') || // Round half up asymmetric negative values\n            (tRound > 5 && settings.mRound === 's')                  || // Round half down symmetric\n            (tRound > 5 && settings.mRound === 'a' && nSign === '')  || // Round half down asymmetric positive values\n            (tRound > 4 && settings.mRound === 'a' && nSign === '-') || // Round half down asymmetric negative values\n            (tRound > 5 && settings.mRound === 'B')                  || // Round half even \"Banker's Rounding\"\n            (tRound === 5 && settings.mRound === 'B' && odd === 1)   || // Round half even \"Banker's Rounding\"\n            (tRound > 0 && settings.mRound === 'C' && nSign === '')  || // Round to ceiling toward positive infinite\n            (tRound > 0 && settings.mRound === 'F' && nSign === '-') || // Round to floor toward negative infinite\n            (tRound > 0 && settings.mRound === 'U')) {                  // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = (ivArray.length - 1); i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        const aDec = settings.aDec;\n        const mDec = settings.mDec;\n        s = (paste === 'paste') ? autoRound(s, settings) : s;\n\n        if (aDec && mDec) {\n            const [integerPart, decimalPart] = s.split(aDec);\n\n            // truncate decimal part to satisfying length since we would round it anyway\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    const modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = `${integerPart}${aDec}${modifiedDecimalPart}`;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        const x = {};\n        let e;\n        let i;\n        let nL;\n        let j;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = (n.search(/[1-9]/i) === -1) ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        const xc = x.c;\n        const yc = y.c;\n        let i = x.s;\n        let j = y.s;\n        let k = x.e;\n        let l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            let result;\n            if (!xc[0]) {\n                result = !yc[0]?0:-j;\n            } else {\n                result = i;\n            }\n            return result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        const xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return (k > l ^ xNeg)?1:-1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = (k < l) ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return (xc[i] > yc[i] ^ xNeg)?1:-1;\n            }\n        }\n\n        // Compare lengths\n        let result;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = (k > l ^ xNeg)?1:-1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        const minParse = parseStr(settings.vMin);\n        const maxParse = parseStr(settings.vMax);\n        const valParse = parseStr(s);\n\n        let result;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(obj)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            obj = `#${obj.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1')}`;\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * Function to attach data to the element and imitate the holder\n     *\n     * @param $that\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getHolder($that, settings, update = false) {\n        let data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        let holder = data.holder;\n        if ((isUndefined(holder) && settings) || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when eDec & nSep options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec     = settings.mDec;\n        settings.oPad     = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep     = settings.aSep;\n        settings.oSign    = settings.aSign;\n        settings.oSuffix  = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        const nameEQ = name + '=';\n        const ca = document.cookie.split(';');\n        let c = '';\n        for (let i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        const mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            const storedName = ($this[0].name !== '' && !isUndefined($this[0].name)) ?`AUTO_${decodeURIComponent($this[0].name)}` :`AUTO_${$this[0].id}`;\n            let date;\n            let expires;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = `${storedName}=${settings.rawValue}; expires= ; path=/`;\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + (-1 * 24 * 60 * 60 * 1000));\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = `${storedName}='' ;${expires}; path=/`;\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     *\n     * @param that\n     * @param {object} settings\n     * @constructor\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n\n        setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start,\n                end,\n                length: end - start,\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n\n        setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n\n        getBeforeAfter() {\n            const value = this.value;\n            const left = value.substring(0, this.selection.start);\n            const right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n\n        getBeforeAfterStriped() {\n            const settingsClone = this.settingsClone;\n            let [left, right] = this.getBeforeAfter();\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = (right === '-') ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts(left, right) {\n            const settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                const m = this.newValue.match(new RegExp(`^${settingsClone.aNegRegAutoStrip}\\\\${settingsClone.aDec}`));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts(left, right, advent) {\n            const settingsClone = this.settingsClone;\n            const parts = this.normalizeParts(left, right);\n            const [minTest, maxTest] = autoCheck(this.newValue, settingsClone);\n            let position = parts[0].length;\n            this.newValue = parts.join('');\n\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                const testValue = (contains(this.newValue, ',')) ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition() {\n            const settingsClone = this.settingsClone;\n            const aSign = settingsClone.aSign;\n            const that = this.that;\n\n            if (aSign) {\n                const aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    const hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                const valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign(setReal) {\n            const signPosition = this.signPosition();\n            const selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                const oldParts = this.valuePartsBeforePaste;\n                const [left, right] = this.getBeforeAfter();\n\n                // try to strip pasted value first\n                delete this.valuePartsBeforePaste;\n                const modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways(e) {\n            const kdCode = this.kdCode;\n            const which = this.which;\n            const ctrlKey = this.ctrlKey;\n            const cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            const shiftKey = this.shiftKey;\n            if (((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste)) || (shiftKey && kdCode === keyCode.Insert)) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if ((kdCode >= keyCode.F1 && kdCode <= keyCode.F12) ||\n                (kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick) ||\n                (kdCode >= keyCode.Tab && kdCode < keyCode.Space) ||\n                (kdCode < keyCode.Backspace &&\n                (which === 0 || which === kdCode)) ||\n                kdCode === keyCode.NumLock ||\n                kdCode === keyCode.ScrollLock ||\n                kdCode === keyCode.Insert ||\n                kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    const valueLen = this.that.value.length;\n                    const aSignLen = this.settings.aSign.length;\n                    const negLen = (!contains(this.that.value, '-'))?0:1;\n                    const aSuffixLen = this.settings.aSuffix.length;\n                    const pSign = this.settings.pSign;\n                    const pNeg = this.settings.pNeg;\n\n                    let start;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = (pNeg === 'l' && negLen === 1 && aSignLen > 0)?aSignLen + 1:aSignLen;\n                    }\n\n                    let end;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = (aSignLen > 0)?valueLen - (aSignLen + negLen + aSuffixLen):valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default :\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                const aSep = this.settingsClone.aSep;\n                const aDec = this.settingsClone.aDec;\n                const startJump = this.selection.start;\n                const value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing([left, right]) {\n            const settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === (this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && ((this.selection.start <= this.value.indexOf(settingsClone.aNeg)) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === (this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= (this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length)) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways() {\n            const settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                let left;\n                let right;\n\n                if (!this.selection.length) {\n                    [left, right] = this.getBeforeAfterStriped();\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if (((settingsClone.pSign === 'p' && settingsClone.pNeg === 's') ||\n                            (settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r'))) &&\n                            contains(this.value, '-')) {\n                        [left, right] = this.processTrailing([left, right]);\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n                    [left, right] = this.getBeforeAfterStriped();\n                    this.setValueParts(left, right);\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress() {\n            const settingsClone = this.settingsClone;\n            const cCode = String.fromCharCode(this.which);\n            let [left, right] = this.getBeforeAfterStriped();\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || (settingsClone.altDec && cCode === settingsClone.altDec) || ((cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad)) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's') || (settingsClone.pSign === 's' && settingsClone.pNeg !== 'p')) {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = (cCode === '-') ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = (cCode === '-') ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick(e) {\n            const settingsClone = this.settingsClone;\n            const leftLength = this.value;\n            const kuCode = e.keyCode;\n            let [left] = this.getBeforeAfterStriped();\n\n            // no grouping separator and no currency sign\n            if ((settingsClone.aSep  === '' || (settingsClone.aSep !== ''  && !contains(leftLength, settingsClone.aSep))) &&\n                (settingsClone.aSign === '' || (settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign)))) {\n                let [subParts] = leftLength.split(settingsClone.aDec);\n                let nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            const value = autoGroup(this.value, this.settingsClone);\n            let position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                const leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || (settingsClone.pSign === 's' && settingsClone.pNeg !== 'p')) && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        const signParts = settingsClone.aSign.split('');\n                        const escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                        const escapedParts = [];\n                        $.each(signParts, (i, miniParts) => {\n                            miniParts = signParts[i];\n                            if (isInArray(miniParts, escapeChr)) {\n                                escapedParts.push('\\\\' + miniParts);\n                            } else {\n                                escapedParts.push(miniParts);\n                            }\n                        });\n                        if (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace) {\n                            escapedParts.push('-');\n                        }\n\n                        // pushing the escaped sign\n                        leftAr.push(escapedParts.join(''));\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                }\n\n                for (let i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                const leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                const newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if (((position === 0 && value.charAt(0) !== settingsClone.aNeg) || (position === 1 && value.charAt(0) === settingsClone.aNeg)) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        },\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray(getArrayBehavior = true, that) {\n        const $this = autoGet(that);\n        const formIndex = $('form').index($this);\n        const allFormElements = $(`form:eq(${formIndex})`)[0];\n        const aiIndex = [];\n\n        // all input index\n        const scIndex = [];\n\n        // successful control index\n        const rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        const rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        const rCheckableType = /^(?:checkbox|radio)$/i;\n        const rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        let count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, (i, field) => {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, (i, field) => {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            const formFields = $this.serializeArray();\n\n            $.each(formFields, (i, field) => {\n                const scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\n                    const settings = testInput.data('autoNumeric');\n\n                    if (typeof settings === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        }\n        else {\n            // getString() behavior\n            const formFields = $this.serialize();\n            const formParts = formFields.split('&');\n\n            $.each(formParts, i => {\n                const [inputName, inputValue] = formParts[i].split('=');\n                const scElement = $.inArray(i, scIndex);\n\n                // If the current element is a valid element\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\n                    const settings = testInput.data('autoNumeric');\n\n                    if (typeof settings === 'object') {\n                        if (inputValue !== null) {\n                            const modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                            formParts[i] = `${inputName}=${modifiedInputValue}`;\n                        }\n                    }\n                }\n            });\n\n            return formParts.join('&');\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusInAndMouseEnter($this, holder) {\n        $this.on('focusin.autoNumeric mouseenter.autoNumeric', e => {\n            holder = getHolder($this);\n            const $settings = holder.settingsClone;\n            if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && $settings.wEmpty === 'focus') {\n                $settings.onOff = true;\n\n                if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                    $this.val(negativeBracket($this.val(), $settings));\n                }\n\n                let result;\n                if ($settings.eDec) {\n                    $settings.mDec = $settings.eDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.scaleDivisor) {\n                    $settings.mDec = $settings.oDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.nSep) {\n                    $settings.aSep = '';\n                    $settings.aSign = '';\n                    $settings.aSuffix = '';\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                    $this.autoNumeric('set', result);\n                }\n\n                holder.inVal = $this.val();\n                holder.lastVal = holder.inVal;\n                const onEmpty = checkEmpty(holder.inVal, $settings, true);\n                if ((onEmpty !== null && onEmpty !== '') && $settings.wEmpty === 'focus') {\n                    $this.val(onEmpty);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keydown' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeydown($this, holder) {\n        $this.on('keydown.autoNumeric', e => {\n            holder = getHolder($this);\n            if (holder.that.readOnly) {\n                holder.processed = true;\n\n                return true;\n            }\n            /* // The code below allows the \"enter\" keydown to throw a change() event\n             if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n             $this.change();\n             holder.inVal = $this.val();\n             } */\n            holder.init(e);\n            if (holder.skipAlways(e)) {\n                holder.processed = true;\n\n                return true;\n            }\n            if (holder.processAlways()) {\n                holder.processed = true;\n                holder.formatQuick(e);\n                const currentValue = $this.val();\n                if ((currentValue !== holder.lastVal) && holder.settingsClone.throwInput) {\n                    // throws input event in deletion character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return false;\n            }\n            holder.formatted = false;\n\n            return true;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keypress' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeypress($this, holder) {\n        $this.on('keypress.autoNumeric', e => {\n            // Firefox fix for Shift && insert paste event\n            if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                return;\n            }\n            holder = getHolder($this);\n            const processed = holder.processed;\n            holder.init(e);\n\n            if (holder.skipAlways(e)) {\n                return true;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return false;\n            }\n\n            if (holder.processAlways() || holder.processKeypress()) {\n                holder.formatQuick(e);\n                const currentValue = $this.val();\n                if ((currentValue !== holder.lastVal) && holder.settingsClone.throwInput) {\n                    // throws input event on adding character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return;\n            }\n            holder.formatted = false;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keyup' events\n     *\n     * @param $this\n     * @param holder\n     * @param settings\n     * @returns {*}\n     */\n    function onKeyup($this, holder, settings) {\n        $this.on('keyup.autoNumeric', function(e) {\n            holder = getHolder($this);\n            holder.init(e);\n            const skip = holder.skipAlways(e);\n            const tab = holder.kdCode;\n            holder.kdCode = 0;\n            delete holder.valuePartsBeforePaste;\n\n\t\t\t// added to properly place the caret when only the currency sign is present\n            if ($this[0].value === holder.settingsClone.aSign) {\n                if (holder.settingsClone.pSign === 's') {\n                    setElementSelection(this, 0, 0);\n                } else {\n                    setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                }\n            } else if (tab === keyCode.Tab) {\n                setElementSelection(this, 0, $this.val().length);\n            }\n\n            if ($this[0].value === holder.settingsClone.aSuffix) {\n                setElementSelection(this, 0, 0);\n            }\n\n            if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                setElementSelection(this, 0, 0);\n            }\n\n            // saves the extended decimal to preserve the data when navigating away from the page\n            if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                autoSave($this, settings, 'set');\n            }\n            if (skip) {\n                return true;\n            }\n            if (this.value === '') {\n                return true;\n            }\n            if (!holder.formatted) {\n                holder.formatQuick(e);\n            }\n        });\n        return holder;\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusOutAndMouseLeave($this, holder) {\n        $this.on('focusout.autoNumeric mouseleave.autoNumeric', () => {\n            if (!$this.is(':focus')) {\n                holder = getHolder($this);\n                let value = $this.val();\n                const origValue = value;\n                const settings = holder.settingsClone;\n                settings.onOff = false;\n                if (settings.aStor) {\n                    autoSave($this, settings, 'set');\n                }\n\n                if (settings.nSep === true) {\n                    settings.aSep = settings.oSep;\n                    settings.aSign = settings.oSign;\n                    settings.aSuffix = settings.oSuffix;\n                }\n\n                if (settings.eDec !== null) {\n                    settings.mDec = settings.oDec;\n                    settings.aPad = settings.oPad;\n                    settings.nBracket = settings.oBracket;\n                }\n\n                value = autoStrip(value, settings);\n                if (value !== '') {\n                    if (settings.trailingNegative) {\n                        value = '-' + value;\n                        settings.trailingNegative = false;\n                    }\n\n                    const [minTest, maxTest] = autoCheck(value, settings);\n                    if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                        value = fixNumber(value, settings);\n                        settings.rawValue = value;\n\n                        if (settings.scaleDivisor) {\n                            value = value / settings.scaleDivisor;\n                            value = value.toString();\n                        }\n\n                        settings.mDec = (settings.scaleDivisor && settings.scaleDecimal) ? +settings.scaleDecimal : settings.mDec;\n                        value = autoRound(value, settings);\n                        value = presentNumber(value, settings);\n                    } else {\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        value = settings.rawValue;\n                    }\n                } else {\n                    if (settings.wEmpty === 'zero') {\n                        settings.rawValue = '0';\n                        value = autoRound('0', settings);\n                    } else {\n                        settings.rawValue = '';\n                    }\n                }\n\n                let groupedValue = checkEmpty(value, settings, false);\n                if (groupedValue === null) {\n                    groupedValue = autoGroup(value, settings);\n                }\n\n                if (groupedValue !== origValue) {\n                    groupedValue = (settings.scaleSymbol) ? groupedValue + settings.scaleSymbol : groupedValue;\n                    $this.val(groupedValue);\n                }\n\n                if (groupedValue !== holder.inVal) {\n                    $this.change();\n                    delete holder.inVal;\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onPaste($this, holder) {\n        $this.on('paste', function(e) {\n\t\t\t//FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n            e.preventDefault();\n            holder = getHolder($this);\n\n            const oldRawValue = $this.autoNumeric('get');\n            const currentValue = this.value || '';\n            const selectionStart = this.selectionStart || 0;\n            const selectionEnd = this.selectionEnd || 0;\n            const prefix = currentValue.substring(0, selectionStart);\n            const suffix = currentValue.substring(selectionEnd, currentValue.length);\n            const pastedText = preparePastedText(e.originalEvent.clipboardData.getData('text/plain'), holder);\n\n            if (isValidPasteText(pastedText)) {\n                const newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n                if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                    $this.autoNumeric('set', newValue);\n                    $this.trigger('input');\n                }\n            } else {\n                this.selectionStart = selectionEnd;\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', () => {\n            holder = getHolder($this);\n\n            if (holder) {\n                const $settings = holder.settingsClone;\n\n                if ($settings.unSetOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param $this\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError(`The input type \"${$this.prop('type')}\" is not supported by autoNumeric`);\n        }\n\n        // Checks for non-supported tags\n        const currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError(`The <${currentElementTag}> tag is not supported by autoNumeric`);\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param settings\n     * @param $input\n     * @param $this\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        let setValue = true;\n\n        if ($input) {\n            const currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.aForm`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `anDefault` altogether.\n             */\n            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                const testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError(`The value [${currentValue}] used in the input is not a valid value autoNumeric can work with.`);\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if ((settings.anDefault !== null && settings.anDefault.toString() !== currentValue) ||\n                    (settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value')) ||\n                    (currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.')))) {\n                    if ((settings.eDec !== null && settings.aStor) ||\n                        (settings.scaleDivisor && settings.aStor)) {\n                        settings.rawValue = autoSave($this, settings, 'get');\n                    }\n\n                    // If the eDec value should NOT be saved in sessionStorage\n                    if (!settings.aStor) {\n                        let toStrip;\n\n                        if (settings.nBracket !== null && settings.aNeg !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = ((settings.pNeg === 's' || (settings.pSign === 's' && settings.pNeg !== 'p')) && settings.aNeg !== '' && contains(currentValue, '-'))?'-' + autoStrip(toStrip, settings):autoStrip(toStrip, settings);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.wEmpty) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.aSign);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default :\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.anDefault !== null) {\n                if (settings.anDefault === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `pNeg` option depending on `aSign` and `pSign`.\n     *\n     * If the user has not set the placement of the negative sign (`pNeg`), but has set a currency symbol (`aSign`),\n     * then we modify the default value of `pNeg` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({aSign: \"$\", pNeg: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({aSign: \"$\", pSign: \"s\", pNeg: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.pNeg) && options.aSign !== '') {\n            switch (settings.pSign) {\n                case 's':\n                    settings.pNeg = 'p';\n                    break;\n                case 'p':\n                    settings.pNeg = 'r';\n                    break;\n                default :\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param options\n     * @param $this\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        let settings = $this.data('autoNumeric');\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if (typeof settings !== 'object') {\n            // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n            const tagData = $this.data();\n\n            settings = $.extend({}, defaultSettings, tagData, options, {\n                onOff           : false,\n                runOnce         : false,\n                rawValue        : '',\n                trailingNegative: false,\n                caretFix        : false,\n                throwInput      : true,\n                strip           : true,\n                tagList         : allowedTagList,\n            });\n\n            // Modify the user settings to make them 'exploitable'\n            $.each(settings, (key, value) => {\n                // Convert the string 'true' and 'false' to real Boolean\n                if (value === 'true' || value === 'false') {\n                    settings[key] = value === 'true';\n                }\n\n                // Convert numbers in options to strings\n                //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                if (typeof value === 'number' && key !== 'aScale') {\n                    settings[key] = value.toString();\n                }\n            });\n\n            // Improve the `pNeg` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign\n            settings.aNeg = settings.vMin < 0 ? '-' : '';\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    const methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init(options) {\n            return this.each(function() {\n                const $this = $(this);\n                const $input = getInputIfSupportedTagAndType($this);\n\n                const settings = getInitialSettings(options, $this);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                let holder = getHolder($this, settings);\n\n                //TODO Shouldn't the next line be in the `getInitialSettings()` function?\n                settings.mDec = (settings.scaleDivisor && settings.scaleDecimal) ? settings.scaleDecimal : settings.mDec;\n\n                if (settings.runOnce === false && settings.aForm) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    holder = onFocusInAndMouseEnter($this, holder);\n                    holder = onFocusOutAndMouseLeave($this, holder);\n                    holder = onKeydown($this, holder);\n                    holder = onKeypress($this, holder);\n                    holder = onKeyup($this, holder, settings);\n                    holder = onPaste($this, holder);\n                    onSubmit($this, holder);\n                }\n            });\n        },\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy() {\n            return $(this).each(function() {\n                const $this = autoGet(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe() {\n            return $(this).each(function() {\n                const $this = autoGet(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update(options) {\n            return $(this).each(function() {\n                //TODO Replace all this duplicated code with a call to `getInitialSettings()`\n                const $this = autoGet(this);\n                let settings = $this.data('autoNumeric');\n\n                if (typeof settings !== 'object') {\n                    throwError(`Initializing autoNumeric is required prior to calling the \"update\" method`);\n                }\n                const strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = (settings.scaleDecimal) ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError(`autoNumeric will not function properly when the decimal character aDec: \"${settings.aDec}\" and thousand separator aSep: \"${settings.aSep}\" are the same character`);\n                }\n\n                // Improve the `pNeg` option if needed\n                correctPNegOption(options, settings);\n\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set(newValue) {\n            return $(this).each(function() {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                const $this = autoGet(this);\n                const settings = $this.data('autoNumeric');\n                const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                let value = newValue.toString();\n                if (typeof settings !== 'object') {\n                    throwError(`Initializing autoNumeric is required prior to calling the \"set\" method`);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    const [minTest, maxTest] = autoCheck(value, settings);\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = (settings.scaleDecimal) ? settings.scaleDecimal : settings.mDec;\n                            }\n\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        const attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError(`The value [${attemptedValue}] being set falls outside of the vMin [${settings.vMin}] and vMax [${settings.vMax}] range set for this element`);\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n         */\n        unSet() {\n            return $(this).each(function() {\n                const $this = autoGet(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet() {\n            return $(this).each(function() {\n                const $this = autoGet(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            const $this = autoGet(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            const settings = $this.data('autoNumeric');\n            if (typeof settings !== 'object') {\n                throwError(`Initializing autoNumeric is required prior to calling the \"get\" method`);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            let value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError(`The \"<${$this.prop('tagName').toLowerCase()}>\" tag is not supported by autoNumeric`);\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!((/\\d/).test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n\n                value = fixNumber(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n        /**\n         * Returns the unformatted value, but following the `outputType` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputType\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized() {\n            const $this = autoGet(this);\n            let value = $this.autoNumeric('get');\n            const settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputType);\n        },\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getString() {\n            return _getStringOrArray(false, this);\n        },\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings() {\n            const $this = autoGet(this);\n\n            return $this.eq(0).data('autoNumeric');\n        },\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     */\n    $.fn.autoNumeric = function(method, ...args) {\n        if (methods[method]) {\n            return methods[method].apply(this, args);\n        }\n\n        if (typeof method === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError(`Method \"${method}\" is not supported by autoNumeric`);\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @return {object}\n     */\n    getDefaultConfig = () => defaultSettings;\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger\n     */\n    autoFormat = (value, options) => {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-'; //TODO Replace this with `getInitialSettings()` that already sets `aNeg`?\n        }\n\n        if (settings.mDec === null) {\n            const vMax = settings.vMax.toString().split('.');\n            const vMin = (!settings.vMin && settings.vMin !== 0) ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n        const [minTest, maxTest] = autoCheck(value, settings);\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', `Range test failed`);\n            throwError(`The value [${value}] being set falls outside of the vMin [${settings.vMin}] and vMax [${settings.vMax}] range set for this element`);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * Public function that allows unformatting without an element\n     */\n    autoUnFormat = (value, options) => {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\n        const allowed = `-0123456789\\\\${settings.aDec}`;\n        const autoStrip = new RegExp(`[^${allowed}]`, 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputType);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = (userOptions, shouldExtendDefaultOptions = true) => {\n        const debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError(`The userOptions are invalid ; it should be a valid object, [${userOptions}] given.`);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        let options;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        const testPositiveInteger = /^[0-9]+$/;\n        const testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        const testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        const testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError(`The thousand separator character option 'aSep' is invalid ; it should be ',', '.', ' ' or empty (''), [${options.aSep}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError(`The 'nSep' option is invalid ; it should be either 'false' or 'true', [${options.nSep}] given.`);\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) { // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError(`The digital grouping for thousand separator option 'dGroup' is invalid ; it should be a positive integer, [${options.dGroup}] given.`);\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError(`The decimal separator character option 'aDec' is invalid ; it should be '.' or ',', [${options.aDec}] given.`);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError(`autoNumeric will not function properly when the decimal character 'aDec' [${options.aDec}] and the thousand separator 'aSep' [${options.aSep}] are the same character.`);\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError(`The alternate decimal separator character option 'altDec' is invalid ; it should be a string, [${options.altDec}] given.`);\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError(`The currency symbol option 'aSign' is invalid ; it should be a string, [${options.aSign}] given.`);\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError(`The placement of the currency sign option 'pSign' is invalid ; it should either be 'p' (prefix) or 's' (suffix), [${options.pSign}] given.`);\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError(`The placement of the negative sign option 'pNeg' is invalid ; it should either be 'p' (prefix), 's' (suffix), 'l' (left) or 'r' (right), [${options.pNeg}] given.`);\n        }\n\n        if (!isString(options.aSuffix) || (options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix)))) {\n            throwError(`The additional suffix option 'aSuffix' is invalid ; it should not contains the negative sign '-' nor any numerical characters, [${options.aSuffix}] given.`);\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError(`The override min & max limits option 'oLimits' is invalid ; it should either be 'ceiling', 'floor' or 'ignore', [${options.oLimits}] given.`);\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError(`The maximum possible value option 'vMax' is invalid ; it should be a string that represents a positive or negative number, [${options.vMax}] given.`);\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError(`The minimum possible value option 'vMin' is invalid ; it should be a string that represents a positive or negative number, [${options.vMin}] given.`);\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError(`The minimum possible value option is greater than the maximum possible value option ; 'vMin' [${options.vMin}] should be smaller than 'vMax' [${options.vMax}].`);\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError(`The maximum number of decimal places option 'mDec' is invalid ; it should be a positive integer, [${options.mDec}] given.`);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning(`Setting 'aPad' to [false] will override the current 'mDec' setting [${options.mDec}].`, debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        let dpVMin = decimalPlaces(options.vMin);\n        let dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin)?0:dpVMin;\n        dpVMax = isNull(dpVMax)?0:dpVMax;\n        const vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) &&\n            ((hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec))) {\n            warning(`Setting 'mDec' to [${options.mDec}] will override the decimals declared in 'vMin' [${options.vMin}] and 'vMax' [${options.vMax}].`, debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError(`The number of expanded decimal places option 'eDec' is invalid ; it should be a positive integer, [${options.eDec}] given.`);\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError(`autoNumeric will not function properly when the extended decimal places 'eDec' [${options.eDec}] is greater than the 'mDec' [${options.mDec}] value.`);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError(`The scale divisor option 'scaleDivisor' is invalid ; it should be a positive number, preferably an integer, [${options.scaleDivisor}] given.`);\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError(`The scale number of decimals option 'scaleDecimal' is invalid ; it should be a positive integer, [${options.scaleDecimal}] given.`);\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError(`The scale symbol option 'scaleSymbol' is invalid ; it should be a string, [${options.scaleSymbol}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError(`The save to session storage option 'aStor' is invalid ; it should be either 'false' or 'true', [${options.aStor}] given.`);\n        }\n\n        if (!isInArray(options.mRound, [\n            'S',\n            'A',\n            's',\n            'a',\n            'B',\n            'U',\n            'D',\n            'C',\n            'F',\n            'N05',\n            'CHF',\n            'U05',\n            'D05',\n        ])) {\n            throwError(`The rounding method option 'mRound' is invalid ; it should either be 'S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05' or 'D05' (cf. documentation), [${options.mRound}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError(`The control decimal padding option 'aPad' is invalid ; it should be either 'false' or 'true', [${options.aPad}] given.`);\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError(`The brackets for negative values option 'nBracket' is invalid ; it should either be '(,)', '[,]', '<,>' or '{,}', [${options.nBracket}] given.`);\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError(`The display on empty string option 'wEmpty' is invalid ; it should either be 'focus', 'press', 'always' or 'zero', [${options.wEmpty}] given.`);\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError(`The leading zero behavior option 'lZero' is invalid ; it should either be 'allow', 'deny' or 'keep', [${options.lZero}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError(`The format on initialization option 'aForm' is invalid ; it should be either 'false' or 'true', [${options.aForm}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError(`The select number only option 'sNumber' is invalid ; it should be either 'false' or 'true', [${options.sNumber}] given.`);\n        }\n\n        if (!isNull(options.anDefault) && (options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault))) {\n            throwError(`The unformatted default value option 'anDefault' is invalid ; it should be a string that represents a positive or negative number, [${options.anDefault}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError(`The remove formatting on submit option 'unSetOnSubmit' is invalid ; it should be either 'false' or 'true', [${options.unSetOnSubmit}] given.`);\n        }\n\n        if (!isNull(options.outputType) && !isInArray(options.outputType, [\n            'string',\n            'number',\n            '.',\n            '-.',\n            ',',\n            '-,',\n            '.-',\n            ',-',\n        ])) {\n            throwError(`The custom locale format option 'outputType' is invalid ; it should either be null, 'string', 'number', '.', '-.', ',', '-,', '.-' or ',-', [${options.outputType}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError(`The debug option 'debug' is invalid ; it should be either 'false' or 'true', [${options.debug}] given.`);\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function(options) {\n        let isValid = true;\n        try {\n            validate(options);\n        }\n        catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName, detail = null) {\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function() {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void(0) };\n            const evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n}));\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexport default {\n    format  : autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig,\n    validate, // an.validate(options) : throws if necessary\n    areSettingsValid, //an.areSettingsValid(options) : return true or false //TODO Is this redundant? Should we let the developers wrap each autoNumeric.validate() calls in try/catch block? Or should we just facilitate their life by doing it already?\n\n    //TODO Complete the interface with functions having the following signatures :\n    //init         : an.init(options, input)\n    //get          : an.get(input)\n    //set          : an.set(value, input)\n    //formString   : an.formString(form)\n    //formArray    : an.formArray(form)\n    //getFormatted : an.getFormatted(input)\n    //unset        : an.unset(input) //to rename to 'unformat'? (and merge with autoUnFormat/unFormat?)\n    //reformat     : an.reformat(input) // 'reSet' is very to close to 'reset' and therefore should be renamed. We could still expose 'reSet', but add a @deprecated tag on its declaration.\n    //settings     : an.settings(input)\n    //update       : an.update(options, input)\n    //wipe         : an.wipe(input)\n    //destroy      : an.destroy(input)\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/autoNumeric.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}